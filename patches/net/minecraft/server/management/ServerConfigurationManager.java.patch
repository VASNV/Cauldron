--- ../src-base/minecraft/net/minecraft/server/management/ServerConfigurationManager.java
+++ ../src-work/minecraft/net/minecraft/server/management/ServerConfigurationManager.java
@@ -49,7 +49,6 @@
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.util.ChatMessageComponent;
 import net.minecraft.util.ChunkCoordinates;
-import net.minecraft.util.EnumChatFormatting;
 import net.minecraft.util.MathHelper;
 import net.minecraft.world.EnumGameType;
 import net.minecraft.world.Teleporter;
@@ -60,7 +59,33 @@
 import net.minecraft.world.storage.IPlayerFileData;
 
 import net.minecraftforge.common.DimensionManager;
+// CraftBukkit start
+import net.minecraft.network.NetLoginHandler;
+import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.chunkio.ChunkIOExecutor;
 
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.TravelAgent;
+import org.bukkit.entity.Player;
+import org.bukkit.event.player.PlayerChangedWorldEvent;
+import org.bukkit.event.player.PlayerPortalEvent;
+import org.bukkit.event.player.PlayerJoinEvent;
+import org.bukkit.event.player.PlayerLoginEvent;
+import org.bukkit.event.player.PlayerQuitEvent;
+import org.bukkit.event.player.PlayerRespawnEvent;
+import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
+import org.bukkit.util.Vector;
+// CraftBukkit end
+
+// Cauldron start
+import net.minecraft.world.WorldProviderEnd;
+import net.minecraftforge.common.network.packet.DimensionRegisterPacket;
+import net.minecraftforge.common.network.ForgePacket;
+import org.bukkit.event.player.PlayerTeleportEvent;
+// Cauldron end
+
 public abstract class ServerConfigurationManager
 {
     private static final SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd \'at\' HH:mm:ss z");
@@ -77,15 +102,15 @@
     private Set ops = new HashSet();
 
     /** The Set of all whitelisted players. */
-    private Set whiteListedPlayers = new HashSet();
+    private Set whiteListedPlayers = new java.util.LinkedHashSet(); // CraftBukkit - HashSet -> LinkedHashSet
 
     /** Reference to the PlayerNBTManager object. */
-    private IPlayerFileData playerNBTManagerObj;
+    public IPlayerFileData playerNBTManagerObj; // CraftBukkit - private -> public
 
     /**
      * Server setting to only allow OPs and whitelisted players to join the server.
      */
-    private boolean whiteListEnforced;
+    public boolean whiteListEnforced; // CraftBukkit - private -> public
 
     /** The maximum number of players that can be connected at a time. */
     protected int maxPlayers;
@@ -99,9 +124,18 @@
      * index into playerEntities of player to ping, updated every tick; currently hardcoded to max at 200 players
      */
     private int playerPingIndex;
+    public boolean allowLoginEvent = false;
 
+    // CraftBukkit start
+    private CraftServer cserver;
+
     public ServerConfigurationManager(MinecraftServer par1MinecraftServer)
     {
+        par1MinecraftServer.server = new CraftServer(par1MinecraftServer, this);
+        par1MinecraftServer.console = org.bukkit.craftbukkit.command.ColouredConsoleSender.getInstance();
+        par1MinecraftServer.reader.addCompleter(new org.bukkit.craftbukkit.command.ConsoleCommandCompleter(par1MinecraftServer.server));
+        this.cserver = par1MinecraftServer.server;
+        // CraftBukkit end
         this.mcServer = par1MinecraftServer;
         this.bannedPlayers.setListActive(false);
         this.bannedIPs.setListActive(false);
@@ -120,19 +154,37 @@
             s = par1INetworkManager.getSocketAddress().toString();
         }
 
-        this.mcServer.getLogAgent().logInfo(par2EntityPlayerMP.getCommandSenderName() + "[" + s + "] logged in with entity id " + par2EntityPlayerMP.entityId + " at (" + par2EntityPlayerMP.posX + ", " + par2EntityPlayerMP.posY + ", " + par2EntityPlayerMP.posZ + ")");
+        // CraftBukkit - add world and location to 'logged in' message.
+        this.mcServer.getLogAgent().logInfo(par2EntityPlayerMP.getCommandSenderName() + "[" + s + "] logged in with entity id " + par2EntityPlayerMP.entityId + " at ([" + par2EntityPlayerMP.worldObj.worldInfo.getWorldName() + "] " + par2EntityPlayerMP.posX + ", " + par2EntityPlayerMP.posY + ", " + par2EntityPlayerMP.posZ + ")");
         WorldServer worldserver = this.mcServer.worldServerForDimension(par2EntityPlayerMP.dimension);
         ChunkCoordinates chunkcoordinates = worldserver.getSpawnPoint();
         this.func_72381_a(par2EntityPlayerMP, (EntityPlayerMP)null, worldserver);
         NetServerHandler netserverhandler = new NetServerHandler(this.mcServer, par1INetworkManager, par2EntityPlayerMP);
-        netserverhandler.sendPacketToPlayer(new Packet1Login(par2EntityPlayerMP.entityId, worldserver.getWorldInfo().getTerrainType(), par2EntityPlayerMP.theItemInWorldManager.getGameType(), worldserver.getWorldInfo().isHardcoreModeEnabled(), worldserver.provider.dimensionId, worldserver.difficultySetting, worldserver.getHeight(), this.getMaxPlayers()));
+        // CraftBukkit start -- Don't send a higher than 60 MaxPlayer size, otherwise the PlayerInfo window won't render correctly.
+        int maxPlayers = this.getMaxPlayers();
+
+        if (maxPlayers > 60)
+        {
+            maxPlayers = 60;
+        }
+
+        // Cauldron start - send DimensionRegisterPacket to client before attempting to login to a Bukkit dimension
+        if (DimensionManager.isBukkitDimension(par2EntityPlayerMP.dimension))
+        {
+            Packet250CustomPayload[] pkt = ForgePacket.makePacketSet(new DimensionRegisterPacket(par2EntityPlayerMP.dimension, worldserver.getWorld().getEnvironment().getId()));
+            par2EntityPlayerMP.playerNetServerHandler.sendPacketToPlayer(pkt[0]);
+        }
+        // Cauldron end
+        netserverhandler.sendPacketToPlayer(new Packet1Login(par2EntityPlayerMP.entityId, worldserver.getWorldInfo().getTerrainType(), par2EntityPlayerMP.theItemInWorldManager.getGameType(), worldserver.getWorldInfo().isHardcoreModeEnabled(), worldserver.provider.dimensionId, worldserver.difficultySetting, worldserver.getHeight(), maxPlayers));
+        par2EntityPlayerMP.getBukkitEntity().sendSupportedChannels();
+        // CraftBukkit end
         netserverhandler.sendPacketToPlayer(new Packet250CustomPayload("MC|Brand", this.getServerInstance().getServerModName().getBytes(Charsets.UTF_8)));
         netserverhandler.sendPacketToPlayer(new Packet6SpawnPosition(chunkcoordinates.posX, chunkcoordinates.posY, chunkcoordinates.posZ));
         netserverhandler.sendPacketToPlayer(new Packet202PlayerAbilities(par2EntityPlayerMP.capabilities));
         netserverhandler.sendPacketToPlayer(new Packet16BlockItemSwitch(par2EntityPlayerMP.inventory.currentItem));
         this.func_96456_a((ServerScoreboard)worldserver.getScoreboard(), par2EntityPlayerMP);
         this.updateTimeAndWeatherForPlayer(par2EntityPlayerMP, worldserver);
-        this.sendChatMsg(ChatMessageComponent.createFromTranslationWithSubstitutions("multiplayer.player.joined", new Object[] {par2EntityPlayerMP.getTranslatedEntityName()}).setColor(EnumChatFormatting.YELLOW));
+        // this.sendAll(new Packet3Chat(EnumChatFormat.YELLOW + entityplayermp.getScoreboardDisplayName() + EnumChatFormat.YELLOW + " joined the game.")); // CraftBukkit - handled in event
         this.playerLoggedIn(par2EntityPlayerMP);
         netserverhandler.setPlayerLocation(par2EntityPlayerMP.posX, par2EntityPlayerMP.posY, par2EntityPlayerMP.posZ, par2EntityPlayerMP.rotationYaw, par2EntityPlayerMP.rotationPitch);
         this.mcServer.getNetworkThread().addPlayer(netserverhandler);
@@ -169,7 +221,7 @@
         }
     }
 
-    protected void func_96456_a(ServerScoreboard par1ServerScoreboard, EntityPlayerMP par2EntityPlayerMP)
+    public void func_96456_a(ServerScoreboard par1ServerScoreboard, EntityPlayerMP par2EntityPlayerMP)   // CraftBukkit - protected -> public
     {
         HashSet hashset = new HashSet();
         Iterator iterator = par1ServerScoreboard.func_96525_g().iterator();
@@ -205,6 +257,11 @@
      */
     public void setPlayerManager(WorldServer[] par1ArrayOfWorldServer)
     {
+        if (this.playerNBTManagerObj != null)
+        {
+            return;    // CraftBukkit
+        }
+
         this.playerNBTManagerObj = par1ArrayOfWorldServer[0].getSaveHandler().getSaveHandler();
     }
 
@@ -231,7 +288,7 @@
      */
     public NBTTagCompound readPlayerDataFromFile(EntityPlayerMP par1EntityPlayerMP)
     {
-        NBTTagCompound nbttagcompound = this.mcServer.worldServers[0].getWorldInfo().getPlayerNBTTagCompound();
+        NBTTagCompound nbttagcompound = this.mcServer.worlds.get(0).getWorldInfo().getPlayerNBTTagCompound(); // CraftBukkit
         NBTTagCompound nbttagcompound1;
 
         if (par1EntityPlayerMP.getCommandSenderName().equals(this.mcServer.getServerOwner()) && nbttagcompound != null)
@@ -261,17 +318,59 @@
      */
     public void playerLoggedIn(EntityPlayerMP par1EntityPlayerMP)
     {
-        this.sendPacketToAllPlayers(new Packet201PlayerInfo(par1EntityPlayerMP.getCommandSenderName(), true, 1000));
+        cserver.detectListNameConflict(par1EntityPlayerMP); // CraftBukkit
+        // this.sendAll(new Packet201PlayerInfo(entityplayermp.name, true, 1000)); // CraftBukkit - replaced with loop below
         this.playerEntityList.add(par1EntityPlayerMP);
         WorldServer worldserver = this.mcServer.worldServerForDimension(par1EntityPlayerMP.dimension);
-        worldserver.spawnEntityInWorld(par1EntityPlayerMP);
-        this.func_72375_a(par1EntityPlayerMP, (WorldServer)null);
+        // CraftBukkit start
+        PlayerJoinEvent playerJoinEvent = new PlayerJoinEvent(this.cserver.getPlayer(par1EntityPlayerMP), "\u00A7e" + par1EntityPlayerMP.getTranslatedEntityName() + " joined the game.");
+        this.cserver.getPluginManager().callEvent(playerJoinEvent);
+        String joinMessage = playerJoinEvent.getJoinMessage();
 
+        if ((joinMessage != null) && (joinMessage.length() > 0))
+        {
+            this.mcServer.getConfigurationManager().sendPacketToAllPlayers(new Packet3Chat(ChatMessageComponent.createFromText(joinMessage)));
+        }
+
+        this.cserver.onPlayerJoin(playerJoinEvent.getPlayer());
+        ChunkIOExecutor.adjustPoolSize(this.getCurrentPlayerCount());
+        // CraftBukkit end
+
+        // CraftBukkit start - Only add if the player wasn't moved in the event
+        if (par1EntityPlayerMP.worldObj == worldserver && !worldserver.playerEntities.contains(par1EntityPlayerMP))
+        {
+            worldserver.spawnEntityInWorld(par1EntityPlayerMP);
+            this.func_72375_a(par1EntityPlayerMP, (WorldServer) null);
+        }
+
+        // CraftBukkit end
+        // CraftBukkit start - sendAll above replaced with this loop
+        Packet201PlayerInfo packet = new Packet201PlayerInfo(par1EntityPlayerMP.listName, true, 1000);
+
         for (int i = 0; i < this.playerEntityList.size(); ++i)
         {
             EntityPlayerMP entityplayermp1 = (EntityPlayerMP)this.playerEntityList.get(i);
-            par1EntityPlayerMP.playerNetServerHandler.sendPacketToPlayer(new Packet201PlayerInfo(entityplayermp1.getCommandSenderName(), true, entityplayermp1.ping));
+
+            if (entityplayermp1.getBukkitEntity().canSee(par1EntityPlayerMP.getBukkitEntity()))
+            {
+                entityplayermp1.playerNetServerHandler.sendPacketToPlayer(packet);
+            }
         }
+
+        // CraftBukkit end
+
+        for (int i = 0; i < this.playerEntityList.size(); ++i)
+        {
+            EntityPlayerMP entityplayermp1 = (EntityPlayerMP)this.playerEntityList.get(i);
+
+            // CraftBukkit start - .name -> .listName
+            if (par1EntityPlayerMP.getBukkitEntity().canSee(entityplayermp1.getBukkitEntity()))
+            {
+                par1EntityPlayerMP.playerNetServerHandler.sendPacketToPlayer(new Packet201PlayerInfo(entityplayermp1.listName, true, entityplayermp1.ping));
+            }
+
+            // CraftBukkit end
+        }
     }
 
     /**
@@ -285,23 +384,57 @@
     /**
      * Called when a player disconnects from the game. Writes player data to disk and removes them from the world.
      */
-    public void playerLoggedOut(EntityPlayerMP par1EntityPlayerMP)
+    public String disconnect(EntityPlayerMP entityplayermp)   // CraftBukkit - return string
     {
-        GameRegistry.onPlayerLogout(par1EntityPlayerMP);
-        this.writePlayerData(par1EntityPlayerMP);
-        WorldServer worldserver = par1EntityPlayerMP.getServerForPlayer();
+        if (entityplayermp.playerNetServerHandler.connectionClosed)
+        {
+            return null;    // CraftBukkit - exploitsies fix
+        }
 
-        if (par1EntityPlayerMP.ridingEntity != null)
+        // CraftBukkit start - Quitting must be before we do final save of data, in case plugins need to modify it
+        org.bukkit.craftbukkit.event.CraftEventFactory.handleInventoryCloseEvent(entityplayermp);
+        PlayerQuitEvent playerQuitEvent = new PlayerQuitEvent(this.cserver.getPlayer(entityplayermp), "\u00A7e" + entityplayermp.username + " left the game.");
+        this.cserver.getPluginManager().callEvent(playerQuitEvent);
+        entityplayermp.getBukkitEntity().disconnect(playerQuitEvent.getQuitMessage());
+        // CraftBukkit end
+        GameRegistry.onPlayerLogout(entityplayermp); // Forge
+        this.writePlayerData(entityplayermp);
+        WorldServer worldserver = entityplayermp.getServerForPlayer();
+
+        if (entityplayermp.ridingEntity != null && !(entityplayermp.ridingEntity instanceof EntityPlayer)) // CraftBukkit - Don't remove players
         {
-            worldserver.removePlayerEntityDangerously(par1EntityPlayerMP.ridingEntity);
-            System.out.println("removing player mount");
+            worldserver.removePlayerEntityDangerously(entityplayermp.ridingEntity);
+            // System.out.println("removing player mount"); // CraftBukkit - Removed debug message
         }
 
-        worldserver.removeEntity(par1EntityPlayerMP);
-        worldserver.getPlayerManager().removePlayer(par1EntityPlayerMP);
-        this.playerEntityList.remove(par1EntityPlayerMP);
-        this.sendPacketToAllPlayers(new Packet201PlayerInfo(par1EntityPlayerMP.getCommandSenderName(), false, 9999));
+        worldserver.removeEntity(entityplayermp);
+        worldserver.getPlayerManager().removePlayer(entityplayermp);
+        this.playerEntityList.remove(entityplayermp);
+        ChunkIOExecutor.adjustPoolSize(this.getCurrentPlayerCount()); // CraftBukkit
+        // CraftBukkit start - .name -> .listName, replace sendAll with loop
+        Packet201PlayerInfo packet = new Packet201PlayerInfo(entityplayermp.listName, false, 9999);
+
+        for (int i = 0; i < this.playerEntityList.size(); ++i)
+        {
+            EntityPlayerMP entityplayermp1 = (EntityPlayerMP)this.playerEntityList.get(i);
+
+            if (entityplayermp1.getBukkitEntity().canSee(entityplayermp.getBukkitEntity()))
+            {
+                entityplayermp1.playerNetServerHandler.sendPacketToPlayer(packet);
+            }
+        }
+
+        // This removes the scoreboard (and player reference) for the specific player in the manager
+        this.cserver.getScoreboardManager().removePlayer(entityplayermp.getBukkitEntity());
+        return playerQuitEvent.getQuitMessage();
+        // CraftBukkit end
     }
+    
+    // Cauldron start - vanilla compatibility
+    public void playerLoggedOut(EntityPlayerMP entityPlayerMP)
+    {
+        disconnect(entityPlayerMP);
+    }
 
     /**
      * checks ban-lists, then white-lists, then space for the server. Returns null on success, or an error message
@@ -349,9 +482,86 @@
         }
     }
 
-    /**
-     * also checks for multiple logins
-     */
+    // CraftBukkit start - Whole method and signature
+    public EntityPlayerMP attemptLogin(NetLoginHandler pendingconnection, String s, String hostname)
+    {
+        // Instead of kicking then returning, we need to store the kick reason
+        // in the event, check with plugins to see if it's ok, and THEN kick
+        // depending on the outcome.
+        EntityPlayerMP entity = new EntityPlayerMP(this.mcServer, this.mcServer.worldServerForDimension(0), s, this.mcServer.isDemo() ? new DemoWorldManager(this.mcServer.worldServerForDimension(0)) : new ItemInWorldManager(this.mcServer.worldServerForDimension(0)));
+        Player player = entity.getBukkitEntity();
+        PlayerLoginEvent event = new PlayerLoginEvent(player, hostname, pendingconnection.getSocket().getInetAddress());
+        // Cauldron start - heavy player load can cause connections to be null so we must validate before attempting to use it
+        SocketAddress socketaddress = null;
+        if (pendingconnection != null && pendingconnection.myTCPConnection != null) socketaddress = pendingconnection.myTCPConnection.getSocketAddress();
+        // Cauldron end
+
+        if (this.bannedPlayers.isBanned(s))
+        {
+            BanEntry banentry = (BanEntry) this.bannedPlayers.getBannedList().get(s);
+            String s1 = "You are banned from this server!\nReason: " + banentry.getBanReason();
+
+            if (banentry.getBanEndDate() != null)
+            {
+                s1 = s1 + "\nYour ban will be removed on " + dateFormat.format(banentry.getBanEndDate());
+            }
+
+            event.disallow(PlayerLoginEvent.Result.KICK_BANNED, s1);
+        }
+        else if (!this.isAllowedToLogin(s))
+        {
+            event.disallow(PlayerLoginEvent.Result.KICK_WHITELIST, org.spigotmc.SpigotConfig.whitelistMessage); // Spigot
+        }
+        else
+        {
+            // Cauldron start - validate socket
+            String s2 = socketaddress != null ? socketaddress.toString() : "";
+            if (!s2.equals(""))
+            {
+                s2 = s2.substring(s2.indexOf("/") + 1);
+                s2 = s2.substring(0, s2.indexOf(":"));
+            }
+
+            if (!s2.equals("") && this.bannedIPs.isBanned(s2))
+            {
+                BanEntry banentry1 = (BanEntry)this.bannedIPs.getBannedList().get(s2);
+                String s3 = "Your IP address is banned from this server!\nReason: " + banentry1.getBanReason();
+
+                if (banentry1.getBanEndDate() != null)
+                {
+                    s3 = s3 + "\nYour ban will be removed on " + dateFormat.format(banentry1.getBanEndDate());
+                }
+
+                event.disallow(PlayerLoginEvent.Result.KICK_BANNED, s3);
+            }
+            else if (this.playerEntityList.size() >= this.maxPlayers)
+            {
+                event.disallow(PlayerLoginEvent.Result.KICK_FULL, org.spigotmc.SpigotConfig.serverFullMessage); // Spigot
+            }
+            else
+            {
+                event.disallow(PlayerLoginEvent.Result.ALLOWED, s2);
+            }
+            // Cauldron end
+        }
+        // Cauldron start - if login event is allowed, execute remaining login code
+        if (allowLoginEvent || event.getResult() != PlayerLoginEvent.Result.ALLOWED)
+        {
+            this.cserver.getPluginManager().callEvent(event);
+        }
+        // Cauldron end
+
+        if (event.getResult() != PlayerLoginEvent.Result.ALLOWED)
+        {
+            pendingconnection.raiseErrorAndDisconnect(event.getKickMessage());
+            return null;
+        }
+
+        return entity;
+        // CraftBukkit end
+    }
+
+    // Cauldron start - vanilla compatibility
     public EntityPlayerMP createPlayerForUser(String par1Str)
     {
         ArrayList arraylist = new ArrayList();
@@ -386,9 +596,51 @@
             object = new ItemInWorldManager(this.mcServer.worldServerForDimension(0));
         }
 
-        return new EntityPlayerMP(this.mcServer, this.mcServer.worldServerForDimension(0), par1Str, (ItemInWorldManager)object);
+        return new EntityPlayerMP(this.mcServer, this.mcServer.worldServerForDimension(0), par1Str, (ItemInWorldManager) object);
     }
+    // Cauldron end
 
+    public EntityPlayerMP processLogin(EntityPlayerMP player)
+    {
+        String s = player.username; // CraftBukkit
+        ArrayList arraylist = new ArrayList();
+        EntityPlayerMP entityplayermp;
+
+        for (int i = 0; i < this.playerEntityList.size(); ++i)
+        {
+            entityplayermp = (EntityPlayerMP)this.playerEntityList.get(i);
+
+            if (entityplayermp.getCommandSenderName().equalsIgnoreCase(s))
+            {
+                arraylist.add(entityplayermp);
+            }
+        }
+
+        Iterator iterator = arraylist.iterator();
+
+        while (iterator.hasNext())
+        {
+            entityplayermp = (EntityPlayerMP)iterator.next();
+            entityplayermp.playerNetServerHandler.kickPlayerFromServer("You logged in from another location");
+        }
+
+        /* CraftBukkit start
+        Object object;
+
+        if (this.server.M()) {
+            object = new DemoPlayerInteractManager(this.server.getWorldServer(0));
+        } else {
+            object = new PlayerInteractManager(this.server.getWorldServer(0));
+        }
+
+        return new EntityPlayer(this.server, this.server.getWorldServer(0), s, (PlayerInteractManager) object);
+        */
+        return player;
+        // CraftBukkit end
+    }
+
+    // CraftBukkit start
+
     /**
      * creates and returns a respawned player based on the provided PlayerEntity. Args are the PlayerEntityMP to
      * respawn, an INT for the dimension to respawn into (usually 0), and a boolean value that is true if the player
@@ -396,100 +648,244 @@
      */
     public EntityPlayerMP respawnPlayer(EntityPlayerMP par1EntityPlayerMP, int par2, boolean par3)
     {
-        World world = mcServer.worldServerForDimension(par2);
+        return this.respawnPlayer(par1EntityPlayerMP, par2, par3, null);
+    }
+
+    public EntityPlayerMP respawnPlayer(EntityPlayerMP par1EntityPlayerMP, int targetDimension, boolean returnFromEnd, Location location)
+    {
+        // Cauldron start - refactor entire method for sanity.
+        // Phase 1 - check if the player is allowed to respawn in same dimension
+        World world = mcServer.worldServerForDimension(targetDimension);
         if (world == null)
         {
-            par2 = 0;
+            targetDimension = 0;
         }
-        else if (!world.provider.canRespawnHere())
+        else if (location == null && !world.provider.canRespawnHere()) // ignore plugins
         {
-            par2 = world.provider.getRespawnDimension(par1EntityPlayerMP);
+            targetDimension = world.provider.getRespawnDimension(par1EntityPlayerMP);
         }
 
+        // Phase 2 - handle return from End
+        if (returnFromEnd)
+        {
+            WorldServer exitWorld = this.mcServer.worldServerForDimension(targetDimension);
+            Location enter = par1EntityPlayerMP.getBukkitEntity().getLocation();
+            Location exit = null;
+            // THE_END -> NORMAL; use bed if available, otherwise default spawn
+            exit = ((org.bukkit.craftbukkit.entity.CraftPlayer) par1EntityPlayerMP.getBukkitEntity()).getBedSpawnLocation();
+
+            if (exit == null || ((CraftWorld) exit.getWorld()).getHandle().dimension != 0)
+            {
+                exit = exitWorld.getWorld().getSpawnLocation();
+            }
+            PlayerPortalEvent event = new PlayerPortalEvent(par1EntityPlayerMP.getBukkitEntity(), enter, exit, org.bukkit.craftbukkit.CraftTravelAgent.DEFAULT, TeleportCause.END_PORTAL);
+            event.useTravelAgent(false);
+            Bukkit.getServer().getPluginManager().callEvent(event);
+            if (event.isCancelled() || event.getTo() == null)
+            {
+                return null;
+            }
+        }
+
+        // Phase 3 - remove current player from current dimension
         par1EntityPlayerMP.getServerForPlayer().getEntityTracker().removePlayerFromTrackers(par1EntityPlayerMP);
-        par1EntityPlayerMP.getServerForPlayer().getEntityTracker().removeEntityFromAllTrackingPlayers(par1EntityPlayerMP);
+        //par1EntityPlayerMP.getServerForPlayer().getEntityTracker().removeEntityFromAllTrackingPlayers(par1EntityPlayerMP);
         par1EntityPlayerMP.getServerForPlayer().getPlayerManager().removePlayer(par1EntityPlayerMP);
         this.playerEntityList.remove(par1EntityPlayerMP);
         this.mcServer.worldServerForDimension(par1EntityPlayerMP.dimension).removePlayerEntityDangerously(par1EntityPlayerMP);
-        ChunkCoordinates chunkcoordinates = par1EntityPlayerMP.getBedLocation(par2);
-        boolean flag1 = par1EntityPlayerMP.isSpawnForced(par2);
-        par1EntityPlayerMP.dimension = par2;
-        Object object;
 
-        if (this.mcServer.isDemo())
-        {
-            object = new DemoWorldManager(this.mcServer.worldServerForDimension(par1EntityPlayerMP.dimension));
-        }
-        else
-        {
-            object = new ItemInWorldManager(this.mcServer.worldServerForDimension(par1EntityPlayerMP.dimension));
-        }
-
-        EntityPlayerMP entityplayermp1 = new EntityPlayerMP(this.mcServer, this.mcServer.worldServerForDimension(par1EntityPlayerMP.dimension), par1EntityPlayerMP.getCommandSenderName(), (ItemInWorldManager)object);
-        entityplayermp1.playerNetServerHandler = par1EntityPlayerMP.playerNetServerHandler;
-        entityplayermp1.clonePlayer(par1EntityPlayerMP, par3);
-        entityplayermp1.dimension = par2;
-        entityplayermp1.entityId = par1EntityPlayerMP.entityId;
-        WorldServer worldserver = this.mcServer.worldServerForDimension(par1EntityPlayerMP.dimension);
-        this.func_72381_a(entityplayermp1, par1EntityPlayerMP, worldserver);
+        // Phase 4 - handle bed spawn
+        ChunkCoordinates bedSpawnChunkCoords = par1EntityPlayerMP.getBedLocation(targetDimension);
+        boolean spawnForced = par1EntityPlayerMP.isSpawnForced(targetDimension);
+        par1EntityPlayerMP.dimension = targetDimension;
+        // CraftBukkit start
+        EntityPlayerMP entityplayermp1 = par1EntityPlayerMP;
+        entityplayermp1.setWorld(this.mcServer.worldServerForDimension(par1EntityPlayerMP.dimension)); // make sure to update reference for bed spawn logic
+        org.bukkit.World fromWorld = entityplayermp1.getBukkitEntity().getWorld();
+        entityplayermp1.playerConqueredTheEnd = false;
         ChunkCoordinates chunkcoordinates1;
+        boolean isBedSpawn = false;
+        org.bukkit.World toWorld = entityplayermp1.getBukkitEntity().getWorld();
 
-        if (chunkcoordinates != null)
+        if (location == null) // use bed logic only if player respawns (player death)
         {
-            chunkcoordinates1 = EntityPlayer.verifyRespawnCoordinates(this.mcServer.worldServerForDimension(par1EntityPlayerMP.dimension), chunkcoordinates, flag1);
-
-            if (chunkcoordinates1 != null)
+            if (bedSpawnChunkCoords != null) // if player has a bed
             {
-                entityplayermp1.setLocationAndAngles((double)((float)chunkcoordinates1.posX + 0.5F), (double)((float)chunkcoordinates1.posY + 0.1F), (double)((float)chunkcoordinates1.posZ + 0.5F), 0.0F, 0.0F);
-                entityplayermp1.setSpawnChunk(chunkcoordinates, flag1);
+                chunkcoordinates1 = EntityPlayer.verifyRespawnCoordinates(this.mcServer.worldServerForDimension(par1EntityPlayerMP.dimension), bedSpawnChunkCoords, spawnForced);
+    
+                if (chunkcoordinates1 != null)
+                {
+                    isBedSpawn = true;
+                    entityplayermp1.setLocationAndAngles((double)((float)chunkcoordinates1.posX + 0.5F), (double)((float)chunkcoordinates1.posY + 0.1F), (double)((float)chunkcoordinates1.posZ + 0.5F), 0.0F, 0.0F);
+                    entityplayermp1.setSpawnChunk(bedSpawnChunkCoords, spawnForced);
+                    location = new Location(toWorld, bedSpawnChunkCoords.posX + 0.5, bedSpawnChunkCoords.posY, bedSpawnChunkCoords.posZ + 0.5);
+                }
+                else // bed was not found (broken)
+                {
+                    //entityplayermp1.setSpawnChunk(null, true); // CraftBukkit
+                    entityplayermp1.playerNetServerHandler.sendPacketToPlayer(new Packet70GameEvent(0, 0));
+                    location = new Location(toWorld, toWorld.getSpawnLocation().getX(), toWorld.getSpawnLocation().getY(), toWorld.getSpawnLocation().getZ()); // use the spawnpoint as location
+                }
             }
-            else
+    
+            if (location == null)
             {
-                entityplayermp1.playerNetServerHandler.sendPacketToPlayer(new Packet70GameEvent(0, 0));
+                location = new Location(toWorld, toWorld.getSpawnLocation().getX(), toWorld.getSpawnLocation().getY(), toWorld.getSpawnLocation().getZ()); // use the world spawnpoint as default location
             }
+    
+            Player respawnPlayer = this.cserver.getPlayer(entityplayermp1);
+            PlayerRespawnEvent respawnEvent = new PlayerRespawnEvent(respawnPlayer, location, isBedSpawn);
+            this.cserver.getPluginManager().callEvent(respawnEvent);
+    
+            if (!spawnForced) // mods override plugins
+            {
+                location = respawnEvent.getRespawnLocation();
+            }
+    
+            par1EntityPlayerMP.reset();
         }
+        else // plugin
+        {
+            location.setWorld(this.mcServer.worldServerForDimension(targetDimension).getWorld());
+        }
 
-        worldserver.theChunkProviderServer.loadChunk((int)entityplayermp1.posX >> 4, (int)entityplayermp1.posZ >> 4);
+        WorldServer targetWorld = ((CraftWorld) location.getWorld()).getHandle();
+        entityplayermp1.setPositionAndRotation(location.getX(), location.getY(), location.getZ(), location.getYaw(), location.getPitch());
+        // CraftBukkit end
+        targetWorld.theChunkProviderServer.loadChunk((int)entityplayermp1.posX >> 4, (int)entityplayermp1.posZ >> 4);
 
-        while (!worldserver.getCollidingBoundingBoxes(entityplayermp1, entityplayermp1.boundingBox).isEmpty())
+        while (!targetWorld.getCollidingBoundingBoxes(entityplayermp1, entityplayermp1.boundingBox).isEmpty())
         {
             entityplayermp1.setPosition(entityplayermp1.posX, entityplayermp1.posY + 1.0D, entityplayermp1.posZ);
         }
 
-        entityplayermp1.playerNetServerHandler.sendPacketToPlayer(new Packet9Respawn(entityplayermp1.dimension, (byte)entityplayermp1.worldObj.difficultySetting, entityplayermp1.worldObj.getWorldInfo().getTerrainType(), entityplayermp1.worldObj.getHeight(), entityplayermp1.theItemInWorldManager.getGameType()));
-        chunkcoordinates1 = worldserver.getSpawnPoint();
-        entityplayermp1.playerNetServerHandler.setPlayerLocation(entityplayermp1.posX, entityplayermp1.posY, entityplayermp1.posZ, entityplayermp1.rotationYaw, entityplayermp1.rotationPitch);
+        // Phase 5 - Respawn player in new world
+        int actualDimension = targetWorld.provider.dimensionId;
+        // Cauldron - change dim for bukkit added dimensions
+        if (DimensionManager.isBukkitDimension(actualDimension))
+        {
+            Packet250CustomPayload[] pkt = ForgePacket.makePacketSet(new DimensionRegisterPacket(actualDimension, targetWorld.getWorld().getEnvironment().getId()));
+            entityplayermp1.playerNetServerHandler.sendPacketToPlayer(pkt[0]);
+        }
+        // Cauldron end
+        // CraftBukkit start
+        entityplayermp1.playerNetServerHandler.sendPacketToPlayer(new Packet9Respawn(actualDimension, (byte) targetWorld.difficultySetting, targetWorld.getWorldInfo().getTerrainType(), targetWorld.getHeight(), par1EntityPlayerMP.theItemInWorldManager.getGameType()));
+        entityplayermp1.setWorld(targetWorld); // in case plugin changed it
+        entityplayermp1.isDead = false;
+        entityplayermp1.playerNetServerHandler.teleport(new Location(targetWorld.getWorld(), entityplayermp1.posX, entityplayermp1.posY, entityplayermp1.posZ, entityplayermp1.rotationYaw, entityplayermp1.rotationPitch));
+        entityplayermp1.setSneaking(false);
+        chunkcoordinates1 = targetWorld.getSpawnPoint();
+        // CraftBukkit end
         entityplayermp1.playerNetServerHandler.sendPacketToPlayer(new Packet6SpawnPosition(chunkcoordinates1.posX, chunkcoordinates1.posY, chunkcoordinates1.posZ));
         entityplayermp1.playerNetServerHandler.sendPacketToPlayer(new Packet43Experience(entityplayermp1.experience, entityplayermp1.experienceTotal, entityplayermp1.experienceLevel));
-        this.updateTimeAndWeatherForPlayer(entityplayermp1, worldserver);
-        worldserver.getPlayerManager().addPlayer(entityplayermp1);
-        worldserver.spawnEntityInWorld(entityplayermp1);
+        this.updateTimeAndWeatherForPlayer(entityplayermp1, targetWorld);
+        targetWorld.getPlayerManager().addPlayer(entityplayermp1);
+        targetWorld.spawnEntityInWorld(entityplayermp1);
         this.playerEntityList.add(entityplayermp1);
         entityplayermp1.addSelfToInternalCraftingInventory();
         entityplayermp1.setHealth(entityplayermp1.getHealth());
-        GameRegistry.onPlayerRespawn(entityplayermp1);
+
+        // If world changed then fire the appropriate change world event else respawn
+        if (fromWorld != location.getWorld())
+        {
+            GameRegistry.onPlayerChangedDimension(par1EntityPlayerMP, (CraftWorld)fromWorld); // Cauldron - fire changed dimension for mods
+        }
+        else GameRegistry.onPlayerRespawn(entityplayermp1);
+
         return entityplayermp1;
     }
 
+    // Cauldron start - refactor transferPlayerToDimension to be compatible with Bukkit. These methods are to be used when a player comes in contact with a portal
     public void transferPlayerToDimension(EntityPlayerMP par1EntityPlayerMP, int par2)
     {
-        transferPlayerToDimension(par1EntityPlayerMP, par2, mcServer.worldServerForDimension(par2).getDefaultTeleporter());
+        this.transferPlayerToDimension(par1EntityPlayerMP, par2, mcServer.worldServerForDimension(par2).getDefaultTeleporter(), PlayerTeleportEvent.TeleportCause.PLUGIN);
     }
 
-    public void transferPlayerToDimension(EntityPlayerMP par1EntityPlayerMP, int par2, Teleporter teleporter)
+    public void transferPlayerToDimension(EntityPlayerMP par1EntityPlayerMP, int par2, Teleporter teleporter) // mods such as Twilight Forest call this method directly
     {
-        int j = par1EntityPlayerMP.dimension;
-        WorldServer worldserver = this.mcServer.worldServerForDimension(par1EntityPlayerMP.dimension);
-        par1EntityPlayerMP.dimension = par2;
-        WorldServer worldserver1 = this.mcServer.worldServerForDimension(par1EntityPlayerMP.dimension);
-        par1EntityPlayerMP.playerNetServerHandler.sendPacketToPlayer(new Packet9Respawn(par1EntityPlayerMP.dimension, (byte)par1EntityPlayerMP.worldObj.difficultySetting, worldserver1.getWorldInfo().getTerrainType(), worldserver1.getHeight(), par1EntityPlayerMP.theItemInWorldManager.getGameType()));
-        worldserver.removePlayerEntityDangerously(par1EntityPlayerMP);
+        this.transferPlayerToDimension(par1EntityPlayerMP, par2, teleporter, TeleportCause.MOD); // use our mod cause
+    }
+
+    public void transferPlayerToDimension(EntityPlayerMP par1EntityPlayerMP, int par2, TeleportCause cause)
+    {
+        this.transferPlayerToDimension(par1EntityPlayerMP, par2, mcServer.worldServerForDimension(par2).getDefaultTeleporter(), cause);
+    }
+
+    public void transferPlayerToDimension(EntityPlayerMP par1EntityPlayerMP, int targetDimension, Teleporter teleporter, TeleportCause cause) // Cauldron - add TeleportCause
+    {
+        // Allow Forge hotloading on teleport
+        WorldServer fromWorld = this.mcServer.worldServerForDimension(par1EntityPlayerMP.dimension);
+        WorldServer exitWorld = this.mcServer.worldServerForDimension(targetDimension);
+
+        // CraftBukkit start - Replaced the standard handling of portals with a more customised method.
+        Location enter = par1EntityPlayerMP.getBukkitEntity().getLocation();
+        Location exit = null;
+        boolean useTravelAgent = false;
+
+        if (exitWorld != null)
+        {
+            exit = this.calculateTarget(enter, exitWorld);
+            if (cause != cause.MOD) // don't use travel agent for custom dimensions
+            {
+                useTravelAgent = true;
+            }
+        }
+
+        // allow forge mods to be the teleporter
+        TravelAgent agent = null;
+        if (exit != null && teleporter == null) 
+        {
+            teleporter = ((CraftWorld)exit.getWorld()).getHandle().getDefaultTeleporter();
+            if (teleporter instanceof TravelAgent) 
+            {
+                agent = (TravelAgent)teleporter;
+            }
+        }
+        else
+        {
+            if (teleporter instanceof TravelAgent) 
+            {
+                agent = (TravelAgent)teleporter;
+            }
+        }
+        if (agent == null) // mod teleporter such as Twilight Forest
+        {
+            agent = org.bukkit.craftbukkit.CraftTravelAgent.DEFAULT; // return arbitrary TA to compensate for implementation dependent plugins
+        }
+
+        PlayerPortalEvent event = new PlayerPortalEvent(par1EntityPlayerMP.getBukkitEntity(), enter, exit, agent, cause);
+        event.useTravelAgent(useTravelAgent);
+        Bukkit.getServer().getPluginManager().callEvent(event);
+
+        if (event.isCancelled() || event.getTo() == null)
+        {
+            return;
+        }
+
+        exit = event.useTravelAgent() && cause != cause.MOD ? event.getPortalTravelAgent().findOrCreate(event.getTo()) : event.getTo(); // make sure plugins don't override travelagent for mods
+
+        if (exit == null)
+        {
+            return;
+        }
+
+        exitWorld = ((CraftWorld) exit.getWorld()).getHandle();
+        Vector velocity = par1EntityPlayerMP.getBukkitEntity().getVelocity();
+        boolean before = exitWorld.theChunkProviderServer.loadChunkOnProvideRequest;
+        exitWorld.theChunkProviderServer.loadChunkOnProvideRequest = true;
+        exitWorld.getDefaultTeleporter().adjustExit(par1EntityPlayerMP, exit, velocity);
+        exitWorld.theChunkProviderServer.loadChunkOnProvideRequest = before;
+        // CraftBukkit end
+
+        par1EntityPlayerMP.dimension = targetDimension;
+        par1EntityPlayerMP.playerNetServerHandler.sendPacketToPlayer(new Packet9Respawn(targetDimension, (byte)par1EntityPlayerMP.worldObj.difficultySetting, exitWorld.getWorldInfo().getTerrainType(), exitWorld.getHeight(), par1EntityPlayerMP.theItemInWorldManager.getGameType()));
+        fromWorld.removePlayerEntityDangerously(par1EntityPlayerMP);
         par1EntityPlayerMP.isDead = false;
-        this.transferEntityToWorld(par1EntityPlayerMP, j, worldserver, worldserver1, teleporter);
-        this.func_72375_a(par1EntityPlayerMP, worldserver);
+        this.transferEntityToWorld(par1EntityPlayerMP, fromWorld.provider.dimensionId, fromWorld, exitWorld, teleporter);
+        this.func_72375_a(par1EntityPlayerMP, fromWorld);
         par1EntityPlayerMP.playerNetServerHandler.setPlayerLocation(par1EntityPlayerMP.posX, par1EntityPlayerMP.posY, par1EntityPlayerMP.posZ, par1EntityPlayerMP.rotationYaw, par1EntityPlayerMP.rotationPitch);
-        par1EntityPlayerMP.theItemInWorldManager.setWorld(worldserver1);
-        this.updateTimeAndWeatherForPlayer(par1EntityPlayerMP, worldserver1);
+        par1EntityPlayerMP.theItemInWorldManager.setWorld(exitWorld);
+        this.updateTimeAndWeatherForPlayer(par1EntityPlayerMP, exitWorld);
         this.syncPlayerInventory(par1EntityPlayerMP);
         Iterator iterator = par1EntityPlayerMP.getActivePotionEffects().iterator();
 
@@ -499,15 +895,18 @@
             par1EntityPlayerMP.playerNetServerHandler.sendPacketToPlayer(new Packet41EntityEffect(par1EntityPlayerMP.entityId, potioneffect));
         }
 
-        GameRegistry.onPlayerChangedDimension(par1EntityPlayerMP);
+        GameRegistry.onPlayerChangedDimension(par1EntityPlayerMP, fromWorld.getWorld());
     }
+    // Cauldron end
 
     /**
      * Transfers an entity from a world to another world.
      */
     public void transferEntityToWorld(Entity par1Entity, int par2, WorldServer par3WorldServer, WorldServer par4WorldServer)
     {
-        transferEntityToWorld(par1Entity, par2, par3WorldServer, par4WorldServer, par4WorldServer.getDefaultTeleporter());
+        // CraftBukkit start - Split into modular functions
+        Location exit = this.calculateTarget(par1Entity.getBukkitEntity().getLocation(), par4WorldServer);
+        this.repositionEntity(par1Entity, exit, true);
     }
 
     public void transferEntityToWorld(Entity par1Entity, int par2, WorldServer par3WorldServer, WorldServer par4WorldServer, Teleporter teleporter)
@@ -569,6 +968,121 @@
         par1Entity.setWorld(par4WorldServer);
     }
 
+    // Copy of original a(Entity, int, WorldServer, WorldServer) method with only location calculation logic
+    public Location calculateTarget(Location enter, World target)
+    {
+        WorldServer worldserver = ((CraftWorld) enter.getWorld()).getHandle();
+        WorldServer worldserver1 = ((CraftWorld) target.getWorld()).getHandle();
+        int i = worldserver.provider.dimensionId;
+        double y = enter.getY();
+        float yaw = enter.getYaw();
+        float pitch = enter.getPitch();
+        double d0 = enter.getX();
+        double d1 = enter.getZ();
+        double d2 = 8.0D;
+
+        if (worldserver1.provider.dimensionId == -1)
+        {
+            d0 /= d2;
+            d1 /= d2;
+            /*
+            entity.setPositionRotation(d0, entity.locY, d1, entity.yaw, entity.pitch);
+            if (entity.isAlive()) {
+                worldserver.entityJoinedWorld(entity, false);
+            }
+            */
+        }
+        else if (worldserver1.provider.dimensionId == 0)
+        {
+            d0 *= d2;
+            d1 *= d2;
+        }
+        else
+        {
+            ChunkCoordinates chunkcoordinates;
+
+            if (i == 1)
+            {
+                // use default NORMAL world spawn instead of target
+                worldserver1 = this.mcServer.worlds.get(0);
+                chunkcoordinates = worldserver1.getSpawnPoint();
+            }
+            else
+            {
+                chunkcoordinates = worldserver1.getEntrancePortalLocation();
+            }
+
+            if (chunkcoordinates != null) // Cauldron
+            {
+                d0 = (double)chunkcoordinates.posX;
+                y = (double) chunkcoordinates.posY;
+                d1 = (double)chunkcoordinates.posZ;
+                yaw = 90.0F;
+                pitch = 0.0F;
+            }
+        }
+
+        if (i != 1)
+        {
+            d0 = (double)MathHelper.clamp_int((int)d0, -29999872, 29999872);
+            d1 = (double)MathHelper.clamp_int((int)d1, -29999872, 29999872);
+        }
+
+        // entity.spawnIn(worldserver1);
+        return new Location(worldserver1.getWorld(), d0, y, d1, yaw, pitch);
+    }
+
+    // copy of original a(Entity, int, WorldServer, WorldServer) method with only entity repositioning logic
+    public void repositionEntity(Entity entity, Location exit, boolean portal)
+    {
+        int i = entity.dimension;
+        WorldServer worldserver = (WorldServer) entity.worldObj;
+        WorldServer worldserver1 = ((CraftWorld) exit.getWorld()).getHandle();
+        worldserver.theProfiler.startSection("moving");
+        entity.setLocationAndAngles(exit.getX(), exit.getY(), exit.getZ(), exit.getYaw(), exit.getPitch());
+
+        if (entity.isEntityAlive())
+        {
+            worldserver.updateEntityWithOptionalForce(entity, false);
+        }
+
+        worldserver.theProfiler.endSection();
+
+        if (i != 1)
+        {
+            worldserver.theProfiler.startSection("placing");
+
+            /*
+            d0 = (double) MathHelper.a((int) d0, -29999872, 29999872);
+            d1 = (double) MathHelper.a((int) d1, -29999872, 29999872);
+            */
+            if (entity.isEntityAlive())
+            {
+                worldserver1.spawnEntityInWorld(entity);
+                // entity.setPositionRotation(d0, entity.locY, d1, entity.yaw, entity.pitch)
+                worldserver1.updateEntityWithOptionalForce(entity, false);
+
+                // worldserver1.s().a(entity, d3, d4, d5, f);
+                if (portal)
+                {
+                    Vector velocity = entity.getBukkitEntity().getVelocity();
+                    worldserver1.getDefaultTeleporter().adjustExit(entity, exit, velocity); // Should be getTravelAgent
+                    entity.setLocationAndAngles(exit.getX(), exit.getY(), exit.getZ(), exit.getYaw(), exit.getPitch());
+
+                    if (entity.motionX != velocity.getX() || entity.motionY != velocity.getY() || entity.motionZ != velocity.getZ())
+                    {
+                        entity.getBukkitEntity().setVelocity(velocity);
+                    }
+                }
+            }
+
+            worldserver.theProfiler.endSection();
+        }
+
+        entity.setWorld(worldserver1);
+        // CraftBukkit end
+    }
+
     /**
      * sends 1 player per tick, but only sends a player once every 600 ticks
      */
@@ -579,11 +1093,13 @@
             this.playerPingIndex = 0;
         }
 
-        if (this.playerPingIndex < this.playerEntityList.size())
-        {
-            EntityPlayerMP entityplayermp = (EntityPlayerMP)this.playerEntityList.get(this.playerPingIndex);
-            this.sendPacketToAllPlayers(new Packet201PlayerInfo(entityplayermp.getCommandSenderName(), true, entityplayermp.ping));
+        /* CraftBukkit start - Remove updating of lag to players -- it spams way to much on big servers.
+        if (this.n < this.players.size()) {
+            EntityPlayer entityplayermp = (EntityPlayer) this.players.get(this.n);
+
+            this.sendAll(new Packet201PlayerInfo(entityplayermp.getName(), true, entityplayermp.ping));
         }
+        // CraftBukkit end */
     }
 
     /**
@@ -664,6 +1180,15 @@
     public void addOp(String par1Str)
     {
         this.ops.add(par1Str.toLowerCase());
+        // CraftBukkit start
+        Player player = mcServer.server.getPlayer(par1Str);
+
+        if (player != null)
+        {
+            player.recalculatePermissions();
+        }
+
+        // CraftBukkit end
     }
 
     /**
@@ -672,6 +1197,15 @@
     public void removeOp(String par1Str)
     {
         this.ops.remove(par1Str.toLowerCase());
+        // CraftBukkit start
+        Player player = mcServer.server.getPlayer(par1Str);
+
+        if (player != null)
+        {
+            player.recalculatePermissions();
+        }
+
+        // CraftBukkit end
     }
 
     /**
@@ -688,7 +1222,8 @@
      */
     public boolean isPlayerOpped(String par1Str)
     {
-        return this.ops.contains(par1Str.trim().toLowerCase()) || this.mcServer.isSinglePlayer() && this.mcServer.worldServers[0].getWorldInfo().areCommandsAllowed() && this.mcServer.getServerOwner().equalsIgnoreCase(par1Str) || this.commandsAllowedForAll;
+        if (par1Str == null) return false; // Cauldron - fixes Aether ServerPlayerAPI initialization which passes a null username
+        return this.ops.contains(par1Str.trim().toLowerCase()) || (this.mcServer.isSinglePlayer() && this.mcServer.worldServers[0].getWorldInfo().areCommandsAllowed() && this.mcServer.getServerOwner().equalsIgnoreCase(par1Str)) || this.commandsAllowedForAll;
     }
 
     public EntityPlayerMP getPlayerForUsername(String par1Str)
@@ -862,12 +1397,26 @@
         {
             EntityPlayerMP entityplayermp = (EntityPlayerMP)this.playerEntityList.get(j);
 
+            // CraftBukkit start - Test if player receiving packet can see the source of the packet
+            if (par1EntityPlayer != null && par1EntityPlayer instanceof EntityPlayerMP && !entityplayermp.getBukkitEntity().canSee(((EntityPlayerMP) par1EntityPlayer).getBukkitEntity()))
+            {
+                continue;
+            }
+
+            // CraftBukkit end
             if (entityplayermp != par1EntityPlayer && entityplayermp.dimension == par10)
             {
                 double d4 = par2 - entityplayermp.posX;
                 double d5 = par4 - entityplayermp.posY;
                 double d6 = par6 - entityplayermp.posZ;
 
+                // Cauldron start - send packets only to players within configured player tracking range)
+                if (par8 > org.spigotmc.TrackingRange.getEntityTrackingRange(entityplayermp, 512))
+                {
+                    par8 = org.spigotmc.TrackingRange.getEntityTrackingRange(entityplayermp, 512);
+                }
+                // Cauldron end
+
                 if (d4 * d4 + d5 * d5 + d6 * d6 < par8 * par8)
                 {
                     entityplayermp.playerNetServerHandler.sendPacketToPlayer(par11Packet);
@@ -930,7 +1479,7 @@
 
         if (par2WorldServer.isRaining())
         {
-            par1EntityPlayerMP.playerNetServerHandler.sendPacketToPlayer(new Packet70GameEvent(1, 0));
+            par1EntityPlayerMP.setPlayerWeather(org.bukkit.WeatherType.DOWNFALL, false); // CraftBukkit - handle player specific weather
         }
     }
 
@@ -940,7 +1489,7 @@
     public void syncPlayerInventory(EntityPlayerMP par1EntityPlayerMP)
     {
         par1EntityPlayerMP.sendContainerToPlayer(par1EntityPlayerMP.inventoryContainer);
-        par1EntityPlayerMP.setPlayerHealthUpdated();
+        par1EntityPlayerMP.getBukkitEntity().updateScaledHealth(); // CraftBukkit - Update scaled health on respawn and worldchange
         par1EntityPlayerMP.playerNetServerHandler.sendPacketToPlayer(new Packet16BlockItemSwitch(par1EntityPlayerMP.inventory.currentItem));
     }
 
@@ -965,7 +1514,10 @@
      */
     public String[] getAvailablePlayerDat()
     {
-        return this.mcServer.worldServers[0].getSaveHandler().getSaveHandler().getAvailablePlayerDat();
+        // Cauldron start - don't crash if the overworld isn't loaded
+        List<WorldServer> worldServers = this.mcServer.worlds;
+        return worldServers.isEmpty() ? new String[0] : worldServers.get(0).getSaveHandler().getSaveHandler().getAvailablePlayerDat(); // CraftBukkit
+        // Cauldron end
     }
 
     public boolean isWhiteListEnabled()
@@ -1054,7 +1606,16 @@
     {
         while (!this.playerEntityList.isEmpty())
         {
-            ((EntityPlayerMP)this.playerEntityList.get(0)).playerNetServerHandler.kickPlayerFromServer("Server closed");
+            // Spigot start
+            EntityPlayerMP p = (EntityPlayerMP) this.playerEntityList.get(0);
+            p.playerNetServerHandler.kickPlayerFromServer(this.mcServer.server.getShutdownMessage());
+
+            if ((!this.playerEntityList.isEmpty()) && (this.playerEntityList.get(0) == p))
+            {
+                this.playerEntityList.remove(0); // Prevent shutdown hang if already disconnected
+            }
+
+            // Spigot end
         }
     }
 
