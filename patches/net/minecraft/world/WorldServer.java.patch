--- ../src-base/minecraft/net/minecraft/world/WorldServer.java
+++ ../src-work/minecraft/net/minecraft/world/WorldServer.java
@@ -2,15 +2,20 @@
 
 import cpw.mods.fml.relauncher.Side;
 import cpw.mods.fml.relauncher.SideOnly;
+
 import java.io.File;
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Random;
 import java.util.Set;
 import java.util.TreeSet;
+
+import gnu.trove.iterator.TLongShortIterator;
 import net.minecraft.block.Block;
+import net.minecraft.block.BlockContainer;
 import net.minecraft.block.BlockEventData;
 import net.minecraft.crash.CrashReport;
 import net.minecraft.crash.CrashReportCategory;
@@ -36,6 +41,18 @@
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.management.PlayerManager;
 import net.minecraft.tileentity.TileEntity;
+import net.minecraft.tileentity.TileEntityBeacon;
+import net.minecraft.tileentity.TileEntityBrewingStand;
+import net.minecraft.tileentity.TileEntityChest;
+import net.minecraft.tileentity.TileEntityDispenser;
+import net.minecraft.tileentity.TileEntityDropper;
+import net.minecraft.tileentity.TileEntityEnderChest;
+import net.minecraft.tileentity.TileEntityFurnace;
+import net.minecraft.tileentity.TileEntityHopper;
+import net.minecraft.tileentity.TileEntityMobSpawner;
+import net.minecraft.tileentity.TileEntityNote;
+import net.minecraft.tileentity.TileEntityRecordPlayer;
+import net.minecraft.tileentity.TileEntitySign;
 import net.minecraft.util.ChunkCoordinates;
 import net.minecraft.util.IProgressUpdate;
 import net.minecraft.util.IntHashMap;
@@ -54,6 +71,7 @@
 import net.minecraft.world.gen.ChunkProviderServer;
 import net.minecraft.world.gen.feature.WorldGeneratorBonusChest;
 import net.minecraft.world.storage.ISaveHandler;
+
 import net.minecraftforge.common.ChestGenHooks;
 import static net.minecraftforge.common.ChestGenHooks.*;
 import net.minecraftforge.common.DimensionManager;
@@ -61,15 +79,27 @@
 import net.minecraftforge.event.ForgeEventFactory;
 import net.minecraftforge.event.world.WorldEvent;
 
+// CraftBukkit start
+import org.bukkit.WeatherType;
+import org.bukkit.block.BlockState;
+import org.bukkit.craftbukkit.util.LongHash;
+import org.bukkit.craftbukkit.util.LongObjectHashMap;
+
+import org.bukkit.event.block.BlockFormEvent;
+import org.bukkit.event.weather.LightningStrikeEvent;
+import org.bukkit.event.weather.ThunderChangeEvent;
+import org.bukkit.event.weather.WeatherChangeEvent;
+// CraftBukkit end
+import mcp.mobius.mobiuscore.profiler.ProfilerSection; // Cauldron - mobius import
+
 public class WorldServer extends World
 {
     private final MinecraftServer mcServer;
-    private final EntityTracker theEntityTracker;
+    public EntityTracker theEntityTracker; // CraftBukkit - private final -> public
     private final PlayerManager thePlayerManager;
-    private Set pendingTickListEntriesHashSet;
-
-    /** All work to do in future ticks. */
-    private TreeSet pendingTickListEntriesTreeSet;
+    private LongObjectHashMap<Set<NextTickListEntry>> tickEntriesByChunk; // Spigot - switch to something better for chunk-wise access
+    private Set pendingTickListEntriesHashSet; // Cauldron - vanilla compatibility
+    private TreeSet<NextTickListEntry> tickEntryQueue; // Spigot
     public ChunkProviderServer theChunkProviderServer;
 
     /** set by CommandServerSave{all,Off,On} */
@@ -96,7 +126,8 @@
      */
     private int blockEventCacheIndex;
     public static final WeightedRandomChestContent[] bonusChestContent = new WeightedRandomChestContent[] {new WeightedRandomChestContent(Item.stick.itemID, 0, 1, 3, 10), new WeightedRandomChestContent(Block.planks.blockID, 0, 1, 3, 10), new WeightedRandomChestContent(Block.wood.blockID, 0, 1, 3, 10), new WeightedRandomChestContent(Item.axeStone.itemID, 0, 1, 1, 3), new WeightedRandomChestContent(Item.axeWood.itemID, 0, 1, 1, 5), new WeightedRandomChestContent(Item.pickaxeStone.itemID, 0, 1, 1, 3), new WeightedRandomChestContent(Item.pickaxeWood.itemID, 0, 1, 1, 5), new WeightedRandomChestContent(Item.appleRed.itemID, 0, 2, 3, 5), new WeightedRandomChestContent(Item.bread.itemID, 0, 2, 3, 3)};
-    private List pendingTickListEntriesThisTick = new ArrayList();
+    private List<NextTickListEntry> pendingTickEntries = new ArrayList<NextTickListEntry>(); // Spigot
+    private int nextPendingTickEntry; // Spigot
 
     /** An IntHashMap of entity IDs (integers) to their Entity objects. */
     private IntHashMap entityIdMap;
@@ -108,6 +139,7 @@
     public WorldServer(MinecraftServer par1MinecraftServer, ISaveHandler par2ISaveHandler, String par3Str, int par4, WorldSettings par5WorldSettings, Profiler par6Profiler, ILogAgent par7ILogAgent)
     {
         super(par2ISaveHandler, par3Str, par5WorldSettings, WorldProvider.getProviderForDimension(par4), par6Profiler, par7ILogAgent);
+        this.dimension = par4;
         this.mcServer = par1MinecraftServer;
         this.theEntityTracker = new EntityTracker(this);
         this.thePlayerManager = new PlayerManager(this, par1MinecraftServer.getConfigurationManager().getViewDistance());
@@ -117,14 +149,15 @@
             this.entityIdMap = new IntHashMap();
         }
 
-        if (this.pendingTickListEntriesHashSet == null)
+        if (this.tickEntriesByChunk == null)
         {
-            this.pendingTickListEntriesHashSet = new HashSet();
+            this.pendingTickListEntriesHashSet = new HashSet(); // Cauldron - vanilla compatibility
+            this.tickEntriesByChunk = new LongObjectHashMap<Set<NextTickListEntry>>();
         }
 
-        if (this.pendingTickListEntriesTreeSet == null)
+        if (this.tickEntryQueue == null)
         {
-            this.pendingTickListEntriesTreeSet = new TreeSet();
+            this.tickEntryQueue = new TreeSet<NextTickListEntry>();
         }
 
         this.worldTeleporter = new Teleporter(this);
@@ -145,11 +178,211 @@
         DimensionManager.setWorld(par4, this);
     }
 
+    public WorldServer(MinecraftServer minecraftServer, ISaveHandler saveHandler, String par2String, WorldProvider provider, WorldSettings par4WorldSettings, Profiler theProfiler, ILogAgent worldLogAgent)
+    {
+        super(saveHandler, par2String, provider, par4WorldSettings, theProfiler, worldLogAgent);
+        this.dimension = provider.dimensionId;
+        this.pvpMode = minecraftServer.isPVPEnabled();
+        this.mcServer = minecraftServer;
+        this.theEntityTracker = null;
+        this.thePlayerManager = null;
+        this.worldTeleporter = null;
+    }
+
+    // CraftBukkit start
+    public final int dimension;
+
+    public WorldServer(MinecraftServer minecraftserver, ISaveHandler isavehandler, String s, int i, WorldSettings worldsettings, Profiler profiler, ILogAgent ilogagent, org.bukkit.World.Environment env, org.bukkit.generator.ChunkGenerator gen)
+    {
+        super(isavehandler, s, worldsettings, WorldProvider.getProviderForDimension(i), profiler, ilogagent, gen, env);
+        this.dimension = i;
+        this.pvpMode = minecraftserver.isPVPEnabled();
+        // CraftBukkit end
+        this.mcServer = minecraftserver;
+        this.theEntityTracker = new EntityTracker(this);
+        this.thePlayerManager = new PlayerManager(this, spigotConfig.viewDistance); // Spigot
+
+        if (this.entityIdMap == null)
+        {
+            this.entityIdMap = new IntHashMap();
+        }
+
+        // Spigot start
+        if (this.tickEntriesByChunk == null)
+        {
+            this.pendingTickListEntriesHashSet = new HashSet(); // Cauldron - vanilla compatibility
+            this.tickEntriesByChunk = new LongObjectHashMap<Set<NextTickListEntry>>();
+        }
+
+        if (this.tickEntryQueue == null)
+        {
+            this.tickEntryQueue = new TreeSet<NextTickListEntry>();
+        }
+
+        // Spigot end
+        this.worldTeleporter = new org.bukkit.craftbukkit.CraftTravelAgent(this); // CraftBukkit
+        this.worldScoreboard = new ServerScoreboard(minecraftserver);
+        ScoreboardSaveData scoreboardsavedata = (ScoreboardSaveData)this.mapStorage.loadData(ScoreboardSaveData.class, "scoreboard");
+
+        if (scoreboardsavedata == null)
+        {
+            scoreboardsavedata = new ScoreboardSaveData();
+            this.mapStorage.setData("scoreboard", scoreboardsavedata);
+        }
+
+        if (!(this instanceof WorldServerMulti)) //Forge: We fix the global mapStorage, which causes us to share scoreboards early. So don't associate the save data with the temporary scoreboard 
+        {
+            scoreboardsavedata.func_96499_a(this.worldScoreboard);
+        }
+        ((ServerScoreboard)this.worldScoreboard).func_96547_a(scoreboardsavedata);
+        DimensionManager.setWorld(i, this);
+    }
+
+    // Cauldron start - wrapper to get CB support
+    public WorldServer(MinecraftServer par1MinecraftServer, ISaveHandler par2ISaveHandler, String par3Str, int par4, ILogAgent ilogagent, WorldSettings par5WorldSettings, Profiler par6Profiler)
+    {
+        this(par1MinecraftServer, par2ISaveHandler, par3Str, par4, par5WorldSettings, par6Profiler, ilogagent, null, null);
+    }
+    // Cauldron end
+
+    // CraftBukkit start
+    @Override
+
     /**
+     * Returns the TileEntity associated with a given block in X,Y,Z coordinates, or null if no TileEntity exists
+     */
+    public TileEntity getBlockTileEntity(int i, int j, int k)
+    {
+        TileEntity result = super.getBlockTileEntity(i, j, k);
+        int type = getBlockId(i, j, k);
+
+        if (type == Block.chest.blockID)
+        {
+            if (!(result instanceof TileEntityChest))
+            {
+                // Cauldron - allow non-vanilla tile entities on chests for Terrafirmacraft, fixes #724
+                //result = fixTileEntity(i, j, k, type, result);
+            }
+        }
+        else if (type == Block.furnaceIdle.blockID)
+        {
+            if (!(result instanceof TileEntityFurnace))
+            {
+                result = fixTileEntity(i, j, k, type, result);
+            }
+        }
+        else if (type == Block.dropper.blockID)
+        {
+            if (!(result instanceof TileEntityDropper))
+            {
+                result = fixTileEntity(i, j, k, type, result);
+            }
+        }
+        else if (type == Block.dispenser.blockID)
+        {
+            if (!(result instanceof TileEntityDispenser))
+            {
+                result = fixTileEntity(i, j, k, type, result);
+            }
+        }
+        else if (type == Block.jukebox.blockID)
+        {
+            if (!(result instanceof TileEntityRecordPlayer))
+            {
+                result = fixTileEntity(i, j, k, type, result);
+            }
+        }
+        else if (type == Block.music.blockID)
+        {
+            if (!(result instanceof TileEntityNote))
+            {
+                result = fixTileEntity(i, j, k, type, result);
+            }
+        }
+        else if (type == Block.mobSpawner.blockID)
+        {
+            if (!(result instanceof TileEntityMobSpawner))
+            {
+                result = fixTileEntity(i, j, k, type, result);
+            }
+        }
+        else if ((type == Block.signPost.blockID) || (type == Block.signWall.blockID))
+        {
+            if (!(result instanceof TileEntitySign))
+            {
+                result = fixTileEntity(i, j, k, type, result);
+            }
+        }
+        else if (type == Block.enderChest.blockID)
+        {
+            if (!(result instanceof TileEntityEnderChest))
+            {
+                result = fixTileEntity(i, j, k, type, result);
+            }
+        }
+        else if (type == Block.brewingStand.blockID)
+        {
+            if (!(result instanceof TileEntityBrewingStand))
+            {
+                result = fixTileEntity(i, j, k, type, result);
+            }
+        }
+        else if (type == Block.beacon.blockID)
+        {
+            if (!(result instanceof TileEntityBeacon))
+            {
+                result = fixTileEntity(i, j, k, type, result);
+            }
+        }
+        else if (type == Block.hopperBlock.blockID)
+        {
+            if (!(result instanceof TileEntityHopper))
+            {
+                result = fixTileEntity(i, j, k, type, result);
+            }
+        }
+
+        return result;
+    }
+
+    private TileEntity fixTileEntity(int x, int y, int z, int type, TileEntity found)
+    {
+        this.getServer().getLogger().severe("Block at " + x + "," + y + "," + z + " is " + org.bukkit.Material.getMaterial(type).toString() + " but has " + found + ". "
+                                            + "Bukkit will attempt to fix this, but there may be additional damage that we cannot recover.");
+
+        if (Block.blocksList[type] instanceof BlockContainer)
+        {
+            TileEntity replacement = ((BlockContainer) Block.blocksList[type]).createNewTileEntity(this);
+            replacement.worldObj = this;
+            this.setBlockTileEntity(x, y, z, replacement);
+            return replacement;
+        }
+        else
+        {
+            this.getServer().getLogger().severe("Don't know how to fix for this type... Can't do anything! :(");
+            return found;
+        }
+    }
+
+    private boolean canSpawn(int x, int z)
+    {
+        if (this.generator != null)
+        {
+            return this.generator.canSpawn(this.getWorld(), x, z);
+        }
+        else
+        {
+            return this.provider.canCoordinateBeSpawn(x, z);
+        }
+    }
+    // CraftBukkit end
+
+    /**
      * Runs a single tick for the world
      */
     public void tick()
     {
+        ProfilerSection.DIMENSION_BLOCKTICK.start(this.provider.dimensionId); // Cauldron - mobius hook
         super.tick();
 
         if (this.getWorldInfo().isHardcoreModeEnabled() && this.difficultySetting < 3)
@@ -171,12 +404,18 @@
         }
 
         this.theProfiler.startSection("mobSpawner");
+        // CraftBukkit start - Only call spawner if we have players online and the world allows for mobs or animals
+        long time = this.worldInfo.getWorldTotalTime();
 
-        if (this.getGameRules().getGameRuleBooleanValue("doMobSpawning"))
+        if (this.getGameRules().getGameRuleBooleanValue("doMobSpawning") && (this.spawnHostileMobs || this.spawnPeacefulMobs) && (this instanceof WorldServer && this.playerEntities.size() > 0))
         {
-            this.animalSpawner.findChunksForSpawning(this, this.spawnHostileMobs, this.spawnPeacefulMobs, this.worldInfo.getWorldTotalTime() % 400L == 0L);
+            timings.mobSpawn.startTiming(); // Spigot
+            this.animalSpawner.findChunksForSpawning(this, this.spawnHostileMobs && (this.ticksPerMonsterSpawns != 0 && time % this.ticksPerMonsterSpawns == 0L), this.spawnPeacefulMobs && (this.ticksPerAnimalSpawns != 0 && time % this.ticksPerAnimalSpawns == 0L), this.worldInfo.getWorldTotalTime() % 400L == 0L);
+            timings.mobSpawn.stopTiming(); // Spigot
         }
 
+        // CraftBukkit end
+        timings.doChunkUnload.startTiming(); // Spigot
         this.theProfiler.endStartSection("chunkSource");
         this.chunkProvider.unloadQueuedChunks();
         int j = this.calculateSkylightSubtracted(1.0F);
@@ -193,23 +432,45 @@
             this.worldInfo.setWorldTime(this.worldInfo.getWorldTime() + 1L);
         }
 
+        timings.doChunkUnload.stopTiming(); // Spigot
         this.theProfiler.endStartSection("tickPending");
+        timings.doTickPending.startTiming(); // Spigot
         this.tickUpdates(false);
+        timings.doTickPending.stopTiming(); // Spigot
         this.theProfiler.endStartSection("tickTiles");
+        timings.doTickTiles.startTiming(); // Spigot
         this.tickBlocksAndAmbiance();
+        timings.doTickTiles.stopTiming(); // Spigot
         this.theProfiler.endStartSection("chunkMap");
+        timings.doChunkMap.startTiming(); // Spigot
         this.thePlayerManager.updatePlayerInstances();
+        timings.doChunkMap.stopTiming(); // Spigot
         this.theProfiler.endStartSection("village");
+        timings.doVillages.startTiming(); // Spigot
         this.villageCollectionObj.tick();
         this.villageSiegeObj.tick();
+        timings.doVillages.stopTiming(); // Spigot
         this.theProfiler.endStartSection("portalForcer");
+        timings.doPortalForcer.startTiming(); // Spigot
         this.worldTeleporter.removeStalePortalLocations(this.getTotalWorldTime());
         for (Teleporter tele : customTeleporters)
         {
             tele.removeStalePortalLocations(getTotalWorldTime());
         }
+        timings.doPortalForcer.stopTiming(); // Spigot
         this.theProfiler.endSection();
+        timings.doSounds.startTiming(); // Spigot
         this.sendAndApplyBlockEvents();
+        timings.doSounds.stopTiming(); // Spigot
+        ProfilerSection.DIMENSION_BLOCKTICK.stop(this.provider.dimensionId); // Cauldron - mobius hook
+        // Cauldron start - if enabled, this can cause issues with IC2 TE's and BoP WorldGen
+        if (this.getServer() != null && this.getServer().chunkGCEnabled)
+        {
+            timings.doChunkGC.startTiming(); // Spigot
+            this.getWorld().processChunkGC(); // CraftBukkit
+            timings.doChunkGC.stopTiming(); // Spigot
+        }
+        // Cauldron end
     }
 
     /**
@@ -234,7 +495,7 @@
         {
             EntityPlayer entityplayer = (EntityPlayer)iterator.next();
 
-            if (!entityplayer.isPlayerSleeping())
+            if (!entityplayer.isPlayerSleeping() && !entityplayer.fauxSleeping)   // CraftBukkit
             {
                 this.allPlayersSleeping = false;
                 break;
@@ -262,7 +523,26 @@
 
     private void resetRainAndThunder()
     {
-        provider.resetRainAndThunder();
+        // CraftBukkit start
+        WeatherChangeEvent weather = new WeatherChangeEvent(this.getWorld(), false);
+        this.getServer().getPluginManager().callEvent(weather);
+        ThunderChangeEvent thunder = new ThunderChangeEvent(this.getWorld(), false);
+        this.getServer().getPluginManager().callEvent(thunder);
+
+        if (!weather.isCancelled())
+        {
+            this.worldInfo.setRainTime(0);
+            this.worldInfo.setRaining(false);
+        }
+
+        if (!thunder.isCancelled())
+        {
+            this.worldInfo.setThunderTime(0);
+            this.worldInfo.setThundering(false);
+        }
+
+        // CraftBukkit end
+        if (!weather.isCancelled() && !thunder.isCancelled()) provider.resetRainAndThunder(); // Cauldron
     }
 
     public boolean areAllPlayersAsleep()
@@ -270,19 +550,28 @@
         if (this.allPlayersSleeping && !this.isRemote)
         {
             Iterator iterator = this.playerEntities.iterator();
+            // CraftBukkit - This allows us to assume that some people are in bed but not really, allowing time to pass in spite of AFKers
+            boolean foundActualSleepers = false;
             EntityPlayer entityplayer;
 
             do
             {
                 if (!iterator.hasNext())
                 {
-                    return true;
+                    return foundActualSleepers; // CraftBukkit
                 }
 
                 entityplayer = (EntityPlayer)iterator.next();
+
+                // CraftBukkit start
+                if (entityplayer.isPlayerFullyAsleep())
+                {
+                    foundActualSleepers = true;
+                }
             }
-            while (entityplayer.isPlayerFullyAsleep());
+            while (entityplayer.isPlayerFullyAsleep() || entityplayer.fauxSleeping);
 
+            // CraftBukkit end
             return false;
         }
         else
@@ -332,30 +621,35 @@
         super.tickBlocksAndAmbiance();
         int i = 0;
         int j = 0;
-        Iterator iterator = this.activeChunkSet.iterator();
+        // CraftBukkit start
+        // Iterator iterator = this.chunkTickList.iterator();
 
-        doneChunks.retainAll(activeChunkSet);
-        if (doneChunks.size() == activeChunkSet.size())
+        // Spigot start
+        for (TLongShortIterator iter = activeChunkSet_CB.iterator(); iter.hasNext();)
         {
-            doneChunks.clear();
-        }
+            iter.advance();
+            long chunkCoord = iter.key();
+            int chunkX = World.keyToX(chunkCoord);
+            int chunkZ = World.keyToZ(chunkCoord);
+            // If unloaded, or in process of being unloaded, drop it
+            if ((!this.chunkExists(chunkX, chunkZ)) || (this.theChunkProviderServer.chunksToUnload.contains(chunkX, chunkZ)))
+            {
+                activeChunkSet.remove(new ChunkCoordIntPair(chunkX, chunkZ)); // Cauldron - vanilla compatibility
+                iter.remove();
+                continue;
+            }
+            // Spigot end
+            // ChunkCoordIntPair chunkcoordintpair = (ChunkCoordIntPair) iterator.next();
+            int k = chunkX * 16;
+            int l = chunkZ * 16;
 
-        final long startTime = System.nanoTime();
-
-        while (iterator.hasNext())
-        {
-            ChunkCoordIntPair chunkcoordintpair = (ChunkCoordIntPair)iterator.next();
-            int k = chunkcoordintpair.chunkXPos * 16;
-            int l = chunkcoordintpair.chunkZPos * 16;
             this.theProfiler.startSection("getChunk");
-            Chunk chunk = this.getChunkFromChunkCoords(chunkcoordintpair.chunkXPos, chunkcoordintpair.chunkZPos);
+            Chunk chunk = this.getChunkFromChunkCoords(chunkX, chunkZ);
+            // CraftBukkit end
+
             this.moodSoundAndLightCheck(k, l, chunk);
             this.theProfiler.endStartSection("tickChunk");
-            //Limits and evenly distributes the lighting update time
-            if (System.nanoTime() - startTime <= 4000000 && doneChunks.add(chunkcoordintpair))
-            {
-                chunk.updateSkylight();
-            }
+            chunk.updateSkylight();
             this.theProfiler.endStartSection("thunder");
             int i1;
             int j1;
@@ -369,7 +663,6 @@
                 j1 = k + (i1 & 15);
                 k1 = l + (i1 >> 8 & 15);
                 l1 = this.getPrecipitationHeight(j1, k1);
-
                 if (this.canLightningStrikeAt(j1, l1, k1))
                 {
                     this.addWeatherEffect(new EntityLightningBolt(this, (double)j1, (double)l1, (double)k1));
@@ -389,12 +682,32 @@
 
                 if (this.isBlockFreezableNaturally(j1 + k, l1 - 1, k1 + l))
                 {
-                    this.setBlock(j1 + k, l1 - 1, k1 + l, Block.ice.blockID);
+                    // CraftBukkit start
+                    BlockState blockState = this.getWorld().getBlockAt(j1 + k, l1 - 1, k1 + l).getState();
+                    blockState.setTypeId(Block.ice.blockID);
+                    BlockFormEvent iceBlockForm = new BlockFormEvent(blockState.getBlock(), blockState);
+                    this.getServer().getPluginManager().callEvent(iceBlockForm);
+                    if (!iceBlockForm.isCancelled())
+                    {
+                        blockState.update(true);
+                    }
+                    // CraftBukkit end
                 }
 
                 if (this.isRaining() && this.canSnowAt(j1 + k, l1, k1 + l))
                 {
-                    this.setBlock(j1 + k, l1, k1 + l, Block.snow.blockID);
+                    // CraftBukkit start
+                    BlockState blockState = this.getWorld().getBlockAt(j1 + k, l1, k1 + l).getState();
+                    blockState.setTypeId(Block.snow.blockID);
+
+                    BlockFormEvent snow = new BlockFormEvent(blockState.getBlock(), blockState);
+                    this.getServer().getPluginManager().callEvent(snow);
+
+                    if (!snow.isCancelled())
+                    {
+                        blockState.update(true);
+                    }
+                    // CraftBukkit end
                 }
 
                 if (this.isRaining())
@@ -404,7 +717,6 @@
                     if (biomegenbase.canSpawnLightningBolt())
                     {
                         i2 = this.getBlockId(j1 + k, l1 - 1, k1 + l);
-
                         if (i2 != 0)
                         {
                             Block.blocksList[i2].fillWithRain(this, j1 + k, l1 - 1, k1 + l);
@@ -415,6 +727,7 @@
 
             this.theProfiler.endStartSection("tickTiles");
             ExtendedBlockStorage[] aextendedblockstorage = chunk.getBlockStorageArray();
+
             j1 = aextendedblockstorage.length;
 
             for (k1 = 0; k1 < j1; ++k1)
@@ -431,12 +744,14 @@
                         int l2 = i2 >> 8 & 15;
                         int i3 = i2 >> 16 & 15;
                         int j3 = extendedblockstorage.getExtBlockID(k2, i3, l2);
+
                         ++j;
                         Block block = Block.blocksList[j3];
 
                         if (block != null && block.getTickRandomly())
                         {
                             ++i;
+                            this.growthOdds = (iter.value() < 1) ? this.modifiedOdds : 100; // Spigot - grow fast if no players are in this chunk (value = player count)
                             block.updateTick(this, k2 + k, i3 + extendedblockstorage.getYLocation(), l2 + l, this.rand);
                         }
                     }
@@ -452,8 +767,21 @@
      */
     public boolean isBlockTickScheduledThisTick(int par1, int par2, int par3, int par4)
     {
-        NextTickListEntry nextticklistentry = new NextTickListEntry(par1, par2, par3, par4);
-        return this.pendingTickListEntriesThisTick.contains(nextticklistentry);
+        // Spigot start
+        int te_cnt = this.pendingTickEntries.size();
+
+        for (int idx = this.nextPendingTickEntry; idx < te_cnt; idx++)
+        {
+            NextTickListEntry ent = this.pendingTickEntries.get(idx);
+
+            if ((ent.xCoord == par1) && (ent.yCoord == par2) && (ent.zCoord == par3) && Block.isAssociatedBlockID(ent.blockID, par4))
+            {
+                return true;
+            }
+        }
+
+        return false;
+        // Spigot end
     }
 
     /**
@@ -502,11 +830,9 @@
                 nextticklistentry.setPriority(par6);
             }
 
-            if (!this.pendingTickListEntriesHashSet.contains(nextticklistentry))
-            {
-                this.pendingTickListEntriesHashSet.add(nextticklistentry);
-                this.pendingTickListEntriesTreeSet.add(nextticklistentry);
-            }
+            // Spigot start
+            addNextTickIfNeeded(nextticklistentry);
+            // Spigot end
         }
     }
 
@@ -523,19 +849,18 @@
             nextticklistentry.setScheduledTime((long)par5 + this.worldInfo.getWorldTotalTime());
         }
 
-        if (!this.pendingTickListEntriesHashSet.contains(nextticklistentry))
-        {
-            this.pendingTickListEntriesHashSet.add(nextticklistentry);
-            this.pendingTickListEntriesTreeSet.add(nextticklistentry);
-        }
+        // Spigot start
+        addNextTickIfNeeded(nextticklistentry);
+        // Spigot end
     }
 
     /**
      * Updates (and cleans up) entities and tile entities
      */
+    /* Cauldron removed so we tick entities even if nobody is on and no persistent chunks exist
     public void updateEntities()
     {
-        if (this.playerEntities.isEmpty() && getPersistentChunks().isEmpty())
+        if (this.playerEntities.isEmpty() && getPersistentChunks().isEmpty()) // Cauldron Use Forge logic here
         {
             if (this.updateEntityTick++ >= 1200)
             {
@@ -549,6 +874,7 @@
 
         super.updateEntities();
     }
+    */
 
     /**
      * Resets the updateEntityTick field to 0
@@ -563,17 +889,24 @@
      */
     public boolean tickUpdates(boolean par1)
     {
-        int i = this.pendingTickListEntriesTreeSet.size();
-
-        if (i != this.pendingTickListEntriesHashSet.size())
+        // Spigot start
+        int i = this.tickEntryQueue.size();
+        this.nextPendingTickEntry = 0;
         {
-            throw new IllegalStateException("TickNextTick list out of synch");
-        }
-        else
-        {
+            // Spigot end
             if (i > 1000)
             {
-                i = 1000;
+                // CraftBukkit start - If the server has too much to process over time, try to alleviate that
+                if (i > 20 * 1000)
+                {
+                    i = i / 20;
+                }
+                else
+                {
+                    i = 1000;
+                }
+
+                // CraftBukkit end
             }
 
             this.theProfiler.startSection("cleaning");
@@ -581,32 +914,31 @@
 
             for (int j = 0; j < i; ++j)
             {
-                nextticklistentry = (NextTickListEntry)this.pendingTickListEntriesTreeSet.first();
+                nextticklistentry = (NextTickListEntry) this.tickEntryQueue.first(); // Spigot
 
                 if (!par1 && nextticklistentry.scheduledTime > this.worldInfo.getWorldTotalTime())
                 {
                     break;
                 }
 
-                this.pendingTickListEntriesTreeSet.remove(nextticklistentry);
-                this.pendingTickListEntriesHashSet.remove(nextticklistentry);
-                this.pendingTickListEntriesThisTick.add(nextticklistentry);
+                // Spigot start
+                this.removeNextTickIfNeeded(nextticklistentry);
+                this.pendingTickEntries.add(nextticklistentry);
+                // Spigot end
             }
 
             this.theProfiler.endSection();
             this.theProfiler.startSection("ticking");
-            Iterator iterator = this.pendingTickListEntriesThisTick.iterator();
 
-            while (iterator.hasNext())
+            // Spigot start
+            for (int j = 0, te_cnt = this.pendingTickEntries.size(); j < te_cnt; j++)
             {
-                nextticklistentry = (NextTickListEntry)iterator.next();
-                iterator.remove();
-                //Keeping here as a note for future when it may be restored.
-                //boolean isForced = getPersistentChunks().containsKey(new ChunkCoordIntPair(nextticklistentry.xCoord >> 4, nextticklistentry.zCoord >> 4));
-                //byte b0 = isForced ? 0 : 8;
+                nextticklistentry = pendingTickEntries.get(j);
+                this.nextPendingTickEntry = j + 1; // treat this as dequeued
+                // Spigot end
                 byte b0 = 0;
 
-                if (this.checkChunksExist(nextticklistentry.xCoord - b0, nextticklistentry.yCoord - b0, nextticklistentry.zCoord - b0, nextticklistentry.xCoord + b0, nextticklistentry.yCoord + b0, nextticklistentry.zCoord + b0))
+                if (this.checkChunksExist(nextticklistentry.xCoord - b0, nextticklistentry.yCoord - b0, nextticklistentry.zCoord - b0, nextticklistentry.xCoord + b0, nextticklistentry.yCoord + b0, nextticklistentry.zCoord + b0) )
                 {
                     int k = this.getBlockId(nextticklistentry.xCoord, nextticklistentry.yCoord, nextticklistentry.zCoord);
 
@@ -643,61 +975,19 @@
             }
 
             this.theProfiler.endSection();
-            this.pendingTickListEntriesThisTick.clear();
-            return !this.pendingTickListEntriesTreeSet.isEmpty();
+            // Spigot start
+            this.pendingTickEntries.clear();
+            this.nextPendingTickEntry = 0;
+            return !this.tickEntryQueue.isEmpty();
+            // Spigot end
         }
     }
 
     public List getPendingBlockUpdates(Chunk par1Chunk, boolean par2)
     {
-        ArrayList arraylist = null;
-        ChunkCoordIntPair chunkcoordintpair = par1Chunk.getChunkCoordIntPair();
-        int i = (chunkcoordintpair.chunkXPos << 4) - 2;
-        int j = i + 16 + 2;
-        int k = (chunkcoordintpair.chunkZPos << 4) - 2;
-        int l = k + 16 + 2;
-
-        for (int i1 = 0; i1 < 2; ++i1)
-        {
-            Iterator iterator;
-
-            if (i1 == 0)
-            {
-                iterator = this.pendingTickListEntriesTreeSet.iterator();
-            }
-            else
-            {
-                iterator = this.pendingTickListEntriesThisTick.iterator();
-
-                if (!this.pendingTickListEntriesThisTick.isEmpty())
-                {
-                    System.out.println(this.pendingTickListEntriesThisTick.size());
-                }
-            }
-
-            while (iterator.hasNext())
-            {
-                NextTickListEntry nextticklistentry = (NextTickListEntry)iterator.next();
-
-                if (nextticklistentry.xCoord >= i && nextticklistentry.xCoord < j && nextticklistentry.zCoord >= k && nextticklistentry.zCoord < l)
-                {
-                    if (par2)
-                    {
-                        this.pendingTickListEntriesHashSet.remove(nextticklistentry);
-                        iterator.remove();
-                    }
-
-                    if (arraylist == null)
-                    {
-                        arraylist = new ArrayList();
-                    }
-
-                    arraylist.add(nextticklistentry);
-                }
-            }
-        }
-
-        return arraylist;
+        // Spigot start
+        return this.getNextTickEntriesForChunk(par1Chunk, par2);
+        // Spigot end
     }
 
     /**
@@ -706,17 +996,38 @@
      */
     public void updateEntityWithOptionalForce(Entity par1Entity, boolean par2)
     {
-        if (!this.mcServer.getCanSpawnAnimals() && (par1Entity instanceof EntityAnimal || par1Entity instanceof EntityWaterMob))
+        /* CraftBukkit start - We prevent spawning in general, so this butchering is not needed
+        if (!this.server.getSpawnAnimals() && (entity instanceof EntityAnimal || entity instanceof EntityWaterAnimal)) {
+            entity.die();
+        }
+        // CraftBukkit end */
+        if (!this.mcServer.getCanSpawnNPCs() && par1Entity instanceof INpc)
         {
             par1Entity.setDead();
         }
 
-        if (!this.mcServer.getCanSpawnNPCs() && par1Entity instanceof INpc)
+        if (!(par1Entity.riddenByEntity instanceof EntityPlayer))
         {
-            par1Entity.setDead();
+            super.updateEntityWithOptionalForce(par1Entity, par2);
         }
+    }
 
-        super.updateEntityWithOptionalForce(par1Entity, par2);
+    /**
+     * direct call to super.updateEntityWithOptionalForce
+     */
+    public void uncheckedUpdateEntity(Entity par1Entity, boolean par2)
+    {
+        try
+        {
+            super.updateEntityWithOptionalForce(par1Entity, par2);
+        }
+        catch (Throwable throwable)
+        {
+            CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Forcefully ticking entity");
+            CrashReportCategory crashreportcategory = crashreport.makeCategory("Entity being force ticked");
+            par1Entity.addEntityCrashInfo(crashreportcategory);
+            throw new ReportedException(crashreport);
+        }
     }
 
     /**
@@ -725,7 +1036,36 @@
     protected IChunkProvider createChunkProvider()
     {
         IChunkLoader ichunkloader = this.saveHandler.getChunkLoader(this.provider);
-        this.theChunkProviderServer = new ChunkProviderServer(this, ichunkloader, this.provider.createChunkGenerator());
+        // Cauldron start - if provider is vanilla, proceed to create a bukkit compatible chunk generator
+        if (this.provider.getClass().toString().length() <= 3 || this.provider.getClass().toString().contains("net.minecraft"))
+        {
+            // CraftBukkit start
+            org.bukkit.craftbukkit.generator.InternalChunkGenerator gen;
+    
+            if (this.generator != null)
+            {
+                gen = new org.bukkit.craftbukkit.generator.CustomChunkGenerator(this, this.getSeed(), this.generator);
+            }
+            else if (this.provider instanceof WorldProviderHell)
+            {
+                gen = new org.bukkit.craftbukkit.generator.NetherChunkGenerator(this, this.getSeed());
+            }
+            else if (this.provider instanceof WorldProviderEnd)
+            {
+                gen = new org.bukkit.craftbukkit.generator.SkyLandsChunkGenerator(this, this.getSeed());
+            }
+            else
+            {
+                gen = new org.bukkit.craftbukkit.generator.NormalChunkGenerator(this, this.getSeed());
+            }
+            this.theChunkProviderServer = new ChunkProviderServer(this, ichunkloader, gen);
+            // CraftBukkit end
+        }
+        else // custom provider, load normally for forge compatibility
+        {
+            this.theChunkProviderServer = new ChunkProviderServer(this, ichunkloader, this.provider.createChunkGenerator());
+        }
+        // Cauldron end
         return this.theChunkProviderServer;
     }
 
@@ -736,28 +1076,31 @@
     {
         ArrayList arraylist = new ArrayList();
 
-        for(int x = (par1 >> 4); x <= (par4 >> 4); x++)
+        // CraftBukkit start - Get tile entities from chunks instead of world
+        for (int chunkX = (par1 >> 4); chunkX <= ((par4 - 1) >> 4); chunkX++)
         {
-            for(int z = (par3 >> 4); z <= (par6 >> 4); z++)
+            for (int chunkZ = (par3 >> 4); chunkZ <= ((par6 - 1) >> 4); chunkZ++)
             {
-                Chunk chunk = getChunkFromChunkCoords(x, z);
-                if (chunk != null)
+                Chunk chunk = getChunkFromChunkCoords(chunkX, chunkZ);
+
+                if (chunk == null)
                 {
-                    for(Object obj : chunk.chunkTileEntityMap.values())
+                    continue;
+                }
+
+                for (Object te : chunk.chunkTileEntityMap.values())
+                {
+                    TileEntity tileentity = (TileEntity) te;
+
+                    if ((tileentity.xCoord >= par1) && (tileentity.yCoord >= par2) && (tileentity.zCoord >= par3) && (tileentity.xCoord < par4) && (tileentity.yCoord < par5) && (tileentity.zCoord < par6))
                     {
-                        TileEntity entity = (TileEntity)obj;
-                        if (!entity.isInvalid())
-                        {
-                            if (entity.xCoord >= par1 && entity.yCoord >= par2 && entity.zCoord >= par3 &&
-                                entity.xCoord <= par4 && entity.yCoord <= par5 && entity.zCoord <= par6)
-                            {
-                                arraylist.add(entity);
-                            }
-                        }
+                        arraylist.add(tileentity);
                     }
                 }
             }
         }
+
+        // CraftBukkit end
         return arraylist;
     }
 
@@ -781,16 +1124,19 @@
             this.entityIdMap = new IntHashMap();
         }
 
-        if (this.pendingTickListEntriesHashSet == null)
+        // Spigot start
+        if (this.tickEntriesByChunk == null)
         {
-            this.pendingTickListEntriesHashSet = new HashSet();
+            this.pendingTickListEntriesHashSet = new HashSet(); // Cauldron - vanilla compatibility
+            this.tickEntriesByChunk = new LongObjectHashMap<Set<NextTickListEntry>>();
         }
 
-        if (this.pendingTickListEntriesTreeSet == null)
+        if (this.tickEntryQueue == null)
         {
-            this.pendingTickListEntriesTreeSet = new TreeSet();
+            this.tickEntryQueue = new TreeSet<NextTickListEntry>();
         }
 
+        // Spigot end
         this.createSpawnPosition(par1WorldSettings);
         super.initialize(par1WorldSettings);
     }
@@ -815,6 +1161,29 @@
             int j = this.provider.getAverageGroundLevel();
             int k = 0;
 
+            // CraftBukkit start
+            if (this.generator != null)
+            {
+                Random rand = new Random(this.getSeed());
+                org.bukkit.Location spawn = this.generator.getFixedSpawnLocation(((WorldServer) this).getWorld(), rand);
+
+                if (spawn != null)
+                {
+                    if (spawn.getWorld() != ((WorldServer) this).getWorld())
+                    {
+                        throw new IllegalStateException("Cannot set spawn point for " + this.worldInfo.getWorldName() + " to be in another world (" + spawn.getWorld().getName() + ")");
+                    }
+                    else
+                    {
+                        this.worldInfo.setSpawnPosition(spawn.getBlockX(), spawn.getBlockY(), spawn.getBlockZ());
+                        this.findingSpawnPoint = false;
+                        return;
+                    }
+                }
+            }
+
+            // CraftBukkit end
+
             if (chunkposition != null)
             {
                 i = chunkposition.x;
@@ -827,7 +1196,7 @@
 
             int l = 0;
 
-            while (!this.provider.canCoordinateBeSpawn(i, k))
+            while (!this.canSpawn(i, k))   // CraftBukkit - use our own canSpawn
             {
                 i += random.nextInt(64) - random.nextInt(64);
                 k += random.nextInt(64) - random.nextInt(64);
@@ -966,9 +1335,23 @@
      */
     public boolean addWeatherEffect(Entity par1Entity)
     {
+        // Cauldron start - vanilla compatibility
+        if (par1Entity instanceof net.minecraft.entity.effect.EntityLightningBolt) 
+        {
+            // CraftBukkit start
+            LightningStrikeEvent lightning = new LightningStrikeEvent(this.getWorld(), (org.bukkit.entity.LightningStrike) par1Entity.getBukkitEntity());
+            this.getServer().getPluginManager().callEvent(lightning);
+    
+            if (lightning.isCancelled())
+            {
+                return false;
+            }
+        } 
+        // Cauldron end
         if (super.addWeatherEffect(par1Entity))
         {
-            this.mcServer.getConfigurationManager().sendToAllNear(par1Entity.posX, par1Entity.posY, par1Entity.posZ, 512.0D, this.provider.dimensionId, new Packet71Weather(par1Entity));
+            this.mcServer.getConfigurationManager().sendToAllNear(par1Entity.posX, par1Entity.posY, par1Entity.posZ, 512.0D, this.dimension, new Packet71Weather(par1Entity));
+            // CraftBukkit end
             return true;
         }
         else
@@ -991,12 +1374,22 @@
      */
     public Explosion newExplosion(Entity par1Entity, double par2, double par4, double par6, float par8, boolean par9, boolean par10)
     {
-        Explosion explosion = new Explosion(this, par1Entity, par2, par4, par6, par8);
-        explosion.isFlaming = par9;
-        explosion.isSmoking = par10;
-        explosion.doExplosionA();
-        explosion.doExplosionB(false);
+        // CraftBukkit start
+        Explosion explosion = super.newExplosion(par1Entity, par2, par4, par6, par8, par9, par10);
 
+        if (explosion.wasCanceled)
+        {
+            return explosion;
+        }
+
+        /* Remove
+        explosion.a = flag;
+        explosion.b = flag1;
+        explosion.a();
+        explosion.a(false);
+        */
+        // CraftBukkit end - TODO: Check if explosions are still properly implemented
+
         if (!par10)
         {
             explosion.affectedBlockPositions.clear();
@@ -1092,14 +1485,16 @@
 
         if (flag != this.isRaining())
         {
-            if (flag)
+            // CraftBukkit start - Only send weather packets to those affected
+            for (int i = 0; i < this.playerEntities.size(); ++i)
             {
-                this.mcServer.getConfigurationManager().sendPacketToAllPlayers(new Packet70GameEvent(2, 0));
+                if (((EntityPlayerMP) this.playerEntities.get(i)).worldObj == this)
+                {
+                    ((EntityPlayerMP) this.playerEntities.get(i)).setPlayerWeather((!flag ? WeatherType.DOWNFALL : WeatherType.CLEAR), false);
+                }
             }
-            else
-            {
-                this.mcServer.getConfigurationManager().sendPacketToAllPlayers(new Packet70GameEvent(1, 0));
-            }
+
+            // CraftBukkit end
         }
     }
 
@@ -1133,4 +1528,97 @@
     {
         return ((AnvilChunkLoader)theChunkProviderServer.currentChunkLoader).chunkSaveLocation;
     }
+
+    // Spigot start
+    private void addNextTickIfNeeded(NextTickListEntry ent)
+    {
+        long coord = LongHash.toLong(ent.xCoord >> 4, ent.zCoord >> 4);
+        Set<NextTickListEntry> chunkset = this.tickEntriesByChunk.get(coord);
+
+        if (chunkset == null)
+        {
+            chunkset = new HashSet<NextTickListEntry>();
+            this.tickEntriesByChunk.put(coord, chunkset);
+        }
+        else if (chunkset.contains(ent))
+        {
+            return;
+        }
+
+        chunkset.add(ent);
+        this.tickEntryQueue.add(ent);
+        this.pendingTickListEntriesHashSet.add(ent); // Cauldron - vanilla compatibility
+    }
+
+    private void removeNextTickIfNeeded(NextTickListEntry ent)
+    {
+        long coord = LongHash.toLong(ent.xCoord >> 4, ent.zCoord >> 4);
+        Set<NextTickListEntry> chunkset = this.tickEntriesByChunk.get(coord);
+
+        if (chunkset != null)
+        {
+            chunkset.remove(ent);
+
+            if (chunkset.isEmpty())
+            {
+                this.tickEntriesByChunk.remove(coord);
+            }
+        }
+
+        this.tickEntryQueue.remove(ent);
+        this.pendingTickListEntriesHashSet.remove(ent); // Cauldron - vanilla compatibility
+    }
+
+    private List<NextTickListEntry> getNextTickEntriesForChunk(Chunk chunk, boolean remove)
+    {
+        long coord = LongHash.toLong(chunk.xPosition, chunk.zPosition);
+        Set<NextTickListEntry> chunkset = this.tickEntriesByChunk.get(coord);
+        List<NextTickListEntry> list = null;
+
+        if (chunkset != null)
+        {
+            list = new ArrayList<NextTickListEntry>(chunkset);
+
+            if (remove)
+            {
+                this.tickEntriesByChunk.remove(coord);
+                this.tickEntryQueue.removeAll(list);
+                chunkset.clear();
+            }
+        }
+
+        // See if any on list of ticks being processed now
+        if (this.nextPendingTickEntry < this.pendingTickEntries.size())
+        {
+            int xmin = (chunk.xPosition << 4);
+            int xmax = xmin + 16;
+            int zmin = (chunk.zPosition << 4);
+            int zmax = zmin + 16;
+            int te_cnt = this.pendingTickEntries.size();
+
+            for (int i = this.nextPendingTickEntry; i < te_cnt; i++)
+            {
+                NextTickListEntry ent = this.pendingTickEntries.get(i);
+
+                if ((ent.xCoord >= xmin) && (ent.xCoord < xmax) && (ent.zCoord >= zmin) && (ent.zCoord < zmax))
+                {
+                    if (list == null)
+                    {
+                        list = new ArrayList<NextTickListEntry>();
+                    }
+
+                    list.add(ent);
+                }
+            }
+        }
+
+        return list;
+    }
+
+    public boolean isEmpty(int a, int b, int c){
+        return isAirBlock(a, b, c);
+    }
+    public int getTypeId(int a, int b, int c){
+        return getBlockId(a, b, c);
+    }
 }
