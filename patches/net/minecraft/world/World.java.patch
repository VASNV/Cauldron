--- ../src-base/minecraft/net/minecraft/world/World.java
+++ ../src-work/minecraft/net/minecraft/world/World.java
@@ -3,6 +3,7 @@
 import cpw.mods.fml.common.FMLLog;
 import cpw.mods.fml.relauncher.Side;
 import cpw.mods.fml.relauncher.SideOnly;
+
 import java.util.ArrayList;
 import java.util.Calendar;
 import java.util.Collection;
@@ -11,6 +12,7 @@
 import java.util.List;
 import java.util.Random;
 import java.util.Set;
+import java.util.concurrent.Callable;
 import net.minecraft.block.Block;
 import net.minecraft.block.BlockFluid;
 import net.minecraft.block.BlockHalfSlab;
@@ -23,11 +25,19 @@
 import net.minecraft.crash.CrashReportCategory;
 import net.minecraft.entity.Entity;
 import net.minecraft.entity.EntityLiving;
+import net.minecraft.entity.EntityLivingBase;
+import net.minecraft.entity.item.EntityItem;
 import net.minecraft.entity.item.EntityMinecart;
+import net.minecraft.entity.monster.EntityGhast;
+import net.minecraft.entity.monster.EntityGolem;
+import net.minecraft.entity.monster.EntityMob;
+import net.minecraft.entity.monster.EntitySlime;
+import net.minecraft.entity.passive.EntityAnimal;
+import net.minecraft.entity.passive.EntityWaterMob;
 import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.entity.player.EntityPlayerMP;
 import net.minecraft.item.ItemStack;
 import net.minecraft.logging.ILogAgent;
-import net.minecraft.nbt.NBTTagCompound;
 import net.minecraft.pathfinding.PathEntity;
 import net.minecraft.pathfinding.PathFinder;
 import net.minecraft.profiler.Profiler;
@@ -37,7 +47,6 @@
 import net.minecraft.tileentity.TileEntity;
 import net.minecraft.util.AxisAlignedBB;
 import net.minecraft.util.ChunkCoordinates;
-import net.minecraft.util.Direction;
 import net.minecraft.util.Facing;
 import net.minecraft.util.MathHelper;
 import net.minecraft.util.MovingObjectPosition;
@@ -50,6 +59,7 @@
 import net.minecraft.world.biome.WorldChunkManager;
 import net.minecraft.world.chunk.Chunk;
 import net.minecraft.world.chunk.IChunkProvider;
+import net.minecraft.world.gen.ChunkProviderServer;
 import net.minecraft.world.storage.ISaveHandler;
 import net.minecraft.world.storage.MapStorage;
 import net.minecraft.world.storage.WorldInfo;
@@ -57,18 +67,44 @@
 import com.google.common.collect.ImmutableSetMultimap;
 
 import net.minecraftforge.client.ForgeHooksClient;
+import net.minecraftforge.common.DimensionManager;
 import net.minecraftforge.common.ForgeChunkManager;
 import net.minecraftforge.common.ForgeChunkManager.Ticket;
 import net.minecraftforge.common.ForgeDummyContainer;
-import net.minecraftforge.common.ForgeHooks;
 import net.minecraftforge.common.MinecraftForge;
 import net.minecraftforge.common.ForgeDirection;
 import net.minecraftforge.common.WorldSpecificSaveHandler;
 import net.minecraftforge.event.entity.EntityEvent;
 import net.minecraftforge.event.entity.EntityJoinWorldEvent;
-import net.minecraftforge.event.world.WorldEvent;
 import net.minecraftforge.event.entity.PlaySoundAtEntityEvent;
 import net.minecraft.entity.EnumCreatureType;
+// CraftBukkit start
+import net.minecraft.entity.item.EntityXPOrb;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.SpigotTimings; // Spigot
+import org.bukkit.generator.ChunkGenerator;
+import org.bukkit.material.MaterialData;
+import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.block.CraftBlockState;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+import org.bukkit.event.block.BlockCanBuildEvent;
+import org.bukkit.event.block.BlockPhysicsEvent;
+import org.bukkit.event.block.BlockPlaceEvent;
+import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
+import org.bukkit.event.weather.WeatherChangeEvent;
+import org.bukkit.event.weather.ThunderChangeEvent;
+// CraftBukkit end
+// Cauldron start
+import mcp.mobius.mobiuscore.profiler.ProfilerSection; // mobius import
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraftforge.cauldron.CauldronHooks;
+import net.minecraftforge.cauldron.configuration.CauldronConfig;
+import net.minecraftforge.cauldron.configuration.CauldronWorldConfig;
+import net.minecraftforge.cauldron.configuration.TileEntityConfig;
+import net.minecraftforge.cauldron.configuration.TileEntityWorldConfig;
+import org.bukkit.block.BlockState;
+// Cauldron end
 
 public abstract class World implements IBlockAccess
 {
@@ -88,14 +124,14 @@
 
     /** A list of all Entities in all currently-loaded chunks */
     public List loadedEntityList = new ArrayList();
-    protected List unloadedEntityList = new ArrayList();
+    public List unloadedEntityList = new ArrayList(); // Cauldron public for reporting purposes
 
     /** A list of all TileEntities in all currently-loaded chunks */
-    public List loadedTileEntityList = new ArrayList();
+    public List loadedTileEntityList = new ArrayList(); // CraftBukkit - ArrayList -> HashSet // Cauldron - keep vanilla for mod compatibility
     private List addedTileEntityList = new ArrayList();
 
     /** Entities marked for removal. */
-    private List entityRemoval = new ArrayList();
+    public List entityRemoval = new ArrayList(); // Cauldron public for reporting purposes
 
     /** Array list of players in the world. */
     public List playerEntities = new ArrayList();
@@ -128,6 +164,7 @@
      * unused.
      */
     public int lastLightningBolt;
+    public boolean restoringBlockStates = false; // CraftBukkit
 
     /** Option > Difficulty setting (0 - 3) */
     public int difficultySetting;
@@ -136,17 +173,17 @@
     public Random rand = new Random();
 
     /** The WorldProvider instance that World uses. */
-    public final WorldProvider provider;
+    public WorldProvider provider; // CraftBukkit - remove final
     protected List worldAccesses = new ArrayList();
 
     /** Handles chunk operations and caching */
-    protected IChunkProvider chunkProvider;
+    public IChunkProvider chunkProvider; // CraftBukkit - protected -> public
     protected final ISaveHandler saveHandler;
 
     /**
      * holds information about a world (size on disk, time, spawn point, seed, ...)
      */
-    protected WorldInfo worldInfo;
+    public WorldInfo worldInfo; // CraftBukkit - protected -> public
 
     /** Boolean that is set to true when trying to find a spawn point */
     public boolean findingSpawnPoint;
@@ -158,21 +195,27 @@
     /** The world-local pool of vectors */
     private final Vec3Pool vecPool = new Vec3Pool(300, 2000);
     private final Calendar theCalendar = Calendar.getInstance();
-    protected Scoreboard worldScoreboard = new Scoreboard();
+    public Scoreboard worldScoreboard = new Scoreboard(); // CraftBukkit - protected -> public
 
     /** The log agent for this world. */
     private final ILogAgent worldLogAgent;
     private ArrayList collidingBoundingBoxes = new ArrayList();
     private boolean scanningTileEntities;
+    // CraftBukkit start - public, longhashset
 
     /** indicates if enemies are spawned or not */
-    protected boolean spawnHostileMobs = true;
+    public boolean spawnHostileMobs = true;
 
     /** A flag indicating whether we should spawn peaceful mobs. */
-    protected boolean spawnPeacefulMobs = true;
+    public boolean spawnPeacefulMobs = true;
 
     /** Positions to update */
-    public Set activeChunkSet = new HashSet();
+    protected gnu.trove.map.hash.TLongShortHashMap activeChunkSet_CB; // Spigot
+    public Set activeChunkSet = new HashSet(); // vanilla compatibility
+    public long ticksPerAnimalSpawns;
+    public long ticksPerMonsterSpawns;
+    private int tickPosition;
+    // CraftBukkit end
 
     /** number of ticks until the next random ambients play */
     private int ambientTickCountdown;
@@ -187,7 +230,51 @@
 
     /** This is set to true for client worlds, and false for server worlds. */
     public boolean isRemote;
+    // Cauldron start - block place
+    public boolean captureBlockStates = false;
+    public boolean captureTreeGeneration = false;
+    public ArrayList<BlockState> capturedBlockStates = new ArrayList<BlockState>();
+    public ArrayList<EntityItem> capturedItems = new ArrayList<EntityItem>();
+    public int entitiesTicked;
+    public int tilesTicked;
+    public CauldronWorldConfig cauldronConfig;
+    public TileEntityWorldConfig tileentityConfig;
+    // preload world crash report classes to fix NCDFE masking StackOverflow/memory error, see #721
+    private static boolean preloadedCrashClasses = false;
+    {
+        if (!preloadedCrashClasses)
+        {
+            // generate a temporary crash report
+            Throwable throwable = new Throwable();
+            CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Exception while updating neighbours");
+            CrashReportCategory crashreportcategory = crashreport.makeCategory("Block being updated");
 
+            // loads all the required classes - including net.minecraft.crash.CallableBlockType (package private)
+            crashreportcategory.addCrashSectionCallable("Source block type", (Callable)(new CallableLvl1(this, 0)));
+            CrashReportCategory.addBlockCrashInfo(crashreportcategory, 0, 0, 0, 0, -1);
+
+            preloadedCrashClasses = true;
+        }
+    }
+    // Cauldron end
+    // Spigot start
+
+    public static long chunkToKey(int x, int z)
+    {
+        long k = ((((long)x) & 0xFFFF0000L) << 16) | ((((long)x) & 0x0000FFFFL) << 0);
+        k |= ((((long)z) & 0xFFFF0000L) << 32) | ((((long)z) & 0x0000FFFFL) << 16);
+        return k;
+    }
+    public static int keyToX(long k)
+    {
+        return (int)(((k >> 16) & 0xFFFF0000) | (k & 0x0000FFFF));
+    }
+    public static int keyToZ(long k)
+    {
+        return (int)(((k >> 32) & 0xFFFF0000L) | ((k >> 16) & 0x0000FFFF));
+    }
+    // Spigot end
+
     /**
      * Gets the biome for a given set of x/z coordinates
      */
@@ -216,6 +303,25 @@
         return this.provider.worldChunkMgr;
     }
 
+    // CraftBukkit start
+    private final CraftWorld world;
+    public boolean pvpMode;
+    public boolean keepSpawnInMemory = false; // Cauldron - default to false to give forge's keepLoaded higher priority
+    public ChunkGenerator generator;
+    private byte chunkTickRadius; // Spigot
+    public org.spigotmc.SpigotWorldConfig spigotConfig; // Spigot
+    public SpigotTimings.WorldTimingsHandler timings; // Spigot
+
+    public CraftWorld getWorld()
+    {
+        return this.world;
+    }
+
+    public CraftServer getServer()
+    {
+        return (CraftServer) Bukkit.getServer();
+    }
+
     @SideOnly(Side.CLIENT)
     public World(ISaveHandler par1ISaveHandler, String par2Str, WorldProvider par3WorldProvider, WorldSettings par4WorldSettings, Profiler par5Profiler, ILogAgent par6ILogAgent)
     {
@@ -227,9 +333,9 @@
         this.provider = par3WorldProvider;
         perWorldStorage = new MapStorage((ISaveHandler)null);
         this.worldLogAgent = par6ILogAgent;
-
+        this.world = null; // Cauldron
     }
-
+    
     // Broken up so that the WorldClient gets the chance to set the mapstorage object before the dimension initializes
     @SideOnly(Side.CLIENT)
     protected void finishSetup()
@@ -255,13 +361,164 @@
         this.calculateInitialWeather();
     }
 
+    // Changed signature
+    public World(ISaveHandler idatamanager, String s, WorldSettings worldsettings, WorldProvider worldprovider, Profiler profiler, ILogAgent ilogagent, ChunkGenerator gen, org.bukkit.World.Environment env)
+    {
+        this.spigotConfig = new org.spigotmc.SpigotWorldConfig( s ); // Spigot
+        // Cauldron start
+        this.cauldronConfig = new CauldronWorldConfig(s, MinecraftServer.getServer().cauldronConfig);
+        this.tileentityConfig = new TileEntityWorldConfig(s, MinecraftServer.getServer().tileEntityConfig);
+        // Cauldron end
+        this.generator = gen;
+        this.worldInfo = idatamanager.loadWorldInfo(); // Spigot
+        this.world = new CraftWorld((WorldServer) this, gen, env);
+        this.ticksPerAnimalSpawns = this.getServer().getTicksPerAnimalSpawns(); // CraftBukkit
+        this.ticksPerMonsterSpawns = this.getServer().getTicksPerMonsterSpawns(); // CraftBukkit
+        this.chunkTickRadius = (byte)((this.getServer().getViewDistance() < 7) ? this.getServer().getViewDistance() : 7); // CraftBukkit - don't tick chunks we don't load for player
+        // CraftBukkit end
+        // Spigot start
+        this.chunkTickRadius = (byte) ( ( this.getServer().getViewDistance() < 7 ) ? this.getServer().getViewDistance() : 7 );
+        this.activeChunkSet_CB = new gnu.trove.map.hash.TLongShortHashMap( spigotConfig.chunksPerTick * 5, 0.7f, Long.MIN_VALUE, Short.MIN_VALUE );
+        this.activeChunkSet_CB.setAutoCompactionFactor( 0 );
+        // Spigot end
+        this.ambientTickCountdown = this.rand.nextInt(12000);
+        this.lightUpdateBlockList = new int[32768];
+        this.isRemote = false;
+        this.saveHandler = idatamanager;
+        this.theProfiler = profiler;
+
+        // Cauldron start
+        // Provides a solution for different worlds getting different copies of the same data, potentially rewriting the data or causing race conditions/stale data
+        // Buildcraft has suffered from the issue this fixes.  If you load the same data from two different worlds they can get two different copies of the same object, thus the last saved gets final say.
+        if (DimensionManager.getWorld(0) != null) // if overworld has loaded, use its mapstorage
+        {
+            this.mapStorage = DimensionManager.getWorld(0).mapStorage;
+        }
+        else // if we are loading overworld, create a new mapstorage
+        {
+            this.mapStorage = new MapStorage(idatamanager);
+        }
+        // Cauldron end
+        this.worldLogAgent = ilogagent;
+        // this.worldInfo = idatamanager.loadWorldInfo(); // Spigot - Moved up
+
+        if (worldprovider != null)
+        {
+            this.provider = worldprovider;
+        }
+        else if (this.worldInfo != null && this.worldInfo.getDimension() != 0)
+        {
+            this.provider = WorldProvider.getProviderForDimension(this.worldInfo.getDimension());
+        }
+        else
+        {
+            this.provider = WorldProvider.getProviderForDimension(0);
+        }
+
+        if (this.worldInfo == null)
+        {
+            this.worldInfo = new WorldInfo(worldsettings, s);
+            this.worldInfo.setDimension(this.provider.dimensionId); // Cauldron - Save dimension to level.dat
+        }
+        else
+        {
+            this.worldInfo.setWorldName(s);
+            // Cauldron start - Use saved dimension from level.dat. Fixes issues with MultiVerse
+            if (this.worldInfo.getDimension() != 0)
+                this.provider.dimensionId = this.worldInfo.getDimension();
+            else
+            {
+                this.worldInfo.setDimension(this.provider.dimensionId);
+            }
+            // Cauldron end
+        }
+
+        // Cauldron start - Guarantee provider dimension is not reset. This is required for mods that rely on the provider ID to match the client dimension. Without this, IC2 will send the wrong ID to clients.
+        int providerId = this.provider.dimensionId;
+        this.provider.registerWorld(this);
+        this.provider.dimensionId = providerId;
+        this.chunkProvider = this.createChunkProvider();
+        // Cauldron start - add Forge
+        if (this instanceof WorldServer)
+        {
+            this.perWorldStorage = new MapStorage(new WorldSpecificSaveHandler((WorldServer)this, idatamanager));
+        }
+        else
+        {
+            this.perWorldStorage = new MapStorage((ISaveHandler)null);
+        }
+        // Cauldron end
+        timings = new SpigotTimings.WorldTimingsHandler(this); // Spigot - code below can generate new world and access timings
+        if (!this.worldInfo.isInitialized())
+        {
+            try
+            {
+                this.initialize(worldsettings);
+            }
+            catch (Throwable throwable)
+            {
+                CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Exception initializing level");
+
+                try
+                {
+                    this.addWorldInfoToCrashReport(crashreport);
+                }
+                catch (Throwable throwable1)
+                {
+                    ;
+                }
+
+                throw new ReportedException(crashreport);
+            }
+
+            this.worldInfo.setServerInitialized(true);
+        }
+        //this.provider.dimensionId = providerId; // Cauldron - Fix for TerrainControl injecting their own WorldProvider
+
+        VillageCollection villagecollection = (VillageCollection)perWorldStorage.loadData(VillageCollection.class, "villages");
+
+        if (villagecollection == null)
+        {
+            this.villageCollectionObj = new VillageCollection(this);
+            this.perWorldStorage.setData("villages", this.villageCollectionObj);
+        }
+        else
+        {
+            this.villageCollectionObj = villagecollection;
+            this.villageCollectionObj.func_82566_a(this);
+        }
+
+        this.calculateInitialSkylight();
+        this.calculateInitialWeather();
+        this.getServer().addWorld(this.world); // CraftBukkit
+    }
+    
     public World(ISaveHandler par1ISaveHandler, String par2Str, WorldSettings par3WorldSettings, WorldProvider par4WorldProvider, Profiler par5Profiler, ILogAgent par6ILogAgent)
     {
+        this.spigotConfig = new org.spigotmc.SpigotWorldConfig( par2Str ); // Spigot
+        // Cauldron start
+        this.cauldronConfig = new CauldronWorldConfig(par2Str, MinecraftServer.getServer().cauldronConfig);
+        this.tileentityConfig = new TileEntityWorldConfig(par2Str, MinecraftServer.getServer().tileEntityConfig);
+        // Cauldron end
+        this.world = null; // CraftWorld not used
         this.ambientTickCountdown = this.rand.nextInt(12000);
         this.lightUpdateBlockList = new int[32768];
+        this.isRemote = false;
         this.saveHandler = par1ISaveHandler;
         this.theProfiler = par5Profiler;
-        this.mapStorage = getMapStorage(par1ISaveHandler);
+
+        // Cauldron start
+        // Provides a solution for different worlds getting different copies of the same data, potentially rewriting the data or causing race conditions/stale data
+        // Buildcraft has suffered from the issue this fixes.  If you load the same data from two different worlds they can get two different copies of the same object, thus the last saved gets final say.
+        if (DimensionManager.getWorld(0) != null) // if overworld has loaded, use its mapstorage
+        {
+            this.mapStorage = DimensionManager.getWorld(0).mapStorage;
+        }
+        else // if we are loading overworld, create a new mapstorage
+        {
+            this.mapStorage = new MapStorage(par1ISaveHandler);
+        }
+        // Cauldron end
         this.worldLogAgent = par6ILogAgent;
         this.worldInfo = par1ISaveHandler.loadWorldInfo();
 
@@ -269,9 +526,9 @@
         {
             this.provider = par4WorldProvider;
         }
-        else if (this.worldInfo != null && this.worldInfo.getVanillaDimension() != 0)
+        else if (this.worldInfo != null && this.worldInfo.getDimension() != 0)
         {
-            this.provider = WorldProvider.getProviderForDimension(this.worldInfo.getVanillaDimension());
+            this.provider = WorldProvider.getProviderForDimension(this.worldInfo.getDimension());
         }
         else
         {
@@ -338,7 +595,9 @@
 
         this.calculateInitialSkylight();
         this.calculateInitialWeather();
+        timings = new SpigotTimings.WorldTimingsHandler(this); // Spigot
     }
+    // Cauldron end    
 
     private static MapStorage s_mapStorage;
     private static ISaveHandler s_savehandler;
@@ -395,6 +654,18 @@
      */
     public int getBlockId(int par1, int par2, int par3)
     {
+        // Cauldron start - tree generation
+        if (captureTreeGeneration) 
+        {
+            for (BlockState blockstate : capturedBlockStates)
+            {
+                if (blockstate.getX() == par1 && blockstate.getY() == par2 && blockstate.getZ() == par3) 
+                {
+                    return blockstate.getTypeId();
+                }
+            }
+        }
+        // Cauldron end
         if (par1 >= -30000000 && par3 >= -30000000 && par1 < 30000000 && par3 < 30000000)
         {
             if (par2 < 0)
@@ -490,7 +761,8 @@
             {
                 for (int l1 = par3; l1 <= par6; ++l1)
                 {
-                    if (!this.chunkExists(k1, l1))
+                    // CraftBukkit - check unload queue too so we don't leak a chunk
+                    if (!this.chunkExists(k1, l1) || ((WorldServer) this).theChunkProviderServer.chunksToUnload.contains(k1, l1))
                     {
                         return false;
                     }
@@ -508,7 +780,7 @@
     /**
      * Returns whether a chunk exists at chunk coordinates x, y
      */
-    protected boolean chunkExists(int par1, int par2)
+    public boolean chunkExists(int par1, int par2) // Cauldron - protected -> public for repackaging
     {
         return this.chunkProvider.chunkExists(par1, par2);
     }
@@ -536,6 +808,33 @@
      */
     public boolean setBlock(int par1, int par2, int par3, int par4, int par5, int par6)
     {
+        // Cauldron start - tree generation
+        if (this.captureTreeGeneration) 
+        {
+            BlockState blockstate = null;
+
+            for (BlockState previous : capturedBlockStates)
+            {
+                if (previous.getX() == par1 && previous.getY() == par2 && previous.getZ() == par3) 
+                {
+                    blockstate = previous;
+                    break;
+                }
+            }
+            if (blockstate != null) 
+            {
+                capturedBlockStates.remove(blockstate);
+            }
+            else
+            {
+                blockstate = org.bukkit.craftbukkit.block.CraftBlockState.getBlockState(this, par1, par2, par3, par6);
+            }
+            blockstate.setTypeId(par4);
+            blockstate.setRawData((byte) par5);
+            this.capturedBlockStates.add(blockstate);
+            return true;
+        }
+        // Cauldron end
         if (par1 >= -30000000 && par3 >= -30000000 && par1 < 30000000 && par3 < 30000000)
         {
             if (par2 < 0)
@@ -555,30 +854,31 @@
                 {
                     k1 = chunk.getBlockID(par1 & 15, par2, par3 & 15);
                 }
+                // Cauldron start - capture blockstates
+                org.bukkit.block.BlockState blockstate = null;
+                if (this.captureBlockStates) {
+                    blockstate = org.bukkit.craftbukkit.block.CraftBlockState.getBlockState(this, par1, par2, par3, par6);
+                    this.capturedBlockStates.add(blockstate);
+                }
 
                 boolean flag = chunk.setBlockIDWithMetadata(par1 & 15, par2, par3 & 15, par4, par5);
+
+                if (!flag && this.captureBlockStates) {
+                    this.capturedBlockStates.remove(blockstate);
+                }
+                // Cauldron end
+
                 this.theProfiler.startSection("checkLight");
                 this.updateAllLightTypes(par1, par2, par3);
                 this.theProfiler.endSection();
 
-                if (flag)
+                // Cauldron start
+                if (flag && !this.captureBlockStates) // Don't notify clients or update physics while capturing blockstates
                 {
-                    if ((par6 & 2) != 0 && (!this.isRemote || (par6 & 4) == 0))
-                    {
-                        this.markBlockForUpdate(par1, par2, par3);
-                    }
-
-                    if (!this.isRemote && (par6 & 1) != 0)
-                    {
-                        this.notifyBlockChange(par1, par2, par3, k1);
-                        Block block = Block.blocksList[par4];
-
-                        if (block != null && block.hasComparatorInputOverride())
-                        {
-                            this.func_96440_m(par1, par2, par3, par4);
-                        }
-                    }
+                    // Modularize client and physic updates
+                    this.markAndNotifyBlock(par1, par2, par3, k1, par4, par6);
                 }
+                // Cauldron end
 
                 return flag;
             }
@@ -589,13 +889,32 @@
         }
     }
 
+    // Cauldron start - Split off from original setBlock(int par1, int par2, int par3, int par4, int par5, int par6) method in order to directly send client and physic updates
+    public void markAndNotifyBlock(int x, int y, int z, int oldId, int newId, int flag)
+    {
+        if ((flag & 2) != 0) // notify clients
+        {
+            this.markBlockForUpdate(x, y, z);
+        }
+        if ((flag & 1) != 0) // update physics
+        {
+            this.notifyBlockChange(x, y, z, oldId);
+            Block block = Block.blocksList[newId];
+            if (block != null && block.hasComparatorInputOverride())
+            {
+                this.func_96440_m(x, y, z, newId);
+            }
+        }
+    }
+    // Cauldron end
+
     /**
      * Returns the block's material.
      */
     public Material getBlockMaterial(int par1, int par2, int par3)
     {
         int l = this.getBlockId(par1, par2, par3);
-        return l == 0 ? Material.air : Block.blocksList[l].blockMaterial;
+        return l == 0 || Block.blocksList[l] == null ? Material.air : Block.blocksList[l].blockMaterial; // Cauldron
     }
 
     /**
@@ -603,6 +922,18 @@
      */
     public int getBlockMetadata(int par1, int par2, int par3)
     {
+        // Cauldron start - tree generation
+        if (captureTreeGeneration) 
+        {
+            for (BlockState blockstate : capturedBlockStates)
+            {
+                if (blockstate.getX() == par1 && blockstate.getY() == par2 && blockstate.getZ() == par3) 
+                {
+                    return blockstate.getRawData();
+                }
+            }
+        }
+        // Cauldron end
         if (par1 >= -30000000 && par3 >= -30000000 && par1 < 30000000 && par3 < 30000000)
         {
             if (par2 < 0)
@@ -842,6 +1173,21 @@
             {
                 try
                 {
+                    // CraftBukkit start
+                    CraftWorld world = ((WorldServer) this).getWorld();
+
+                    if (world != null)
+                    {
+                        BlockPhysicsEvent event = new BlockPhysicsEvent(world.getBlockAt(par1, par2, par3), par4);
+                        this.getServer().getPluginManager().callEvent(event);
+
+                        if (event.isCancelled())
+                        {
+                            return;
+                        }
+                    }
+
+                    // CraftBukkit end
                     block.onNeighborBlockChange(this, par1, par2, par3, par4);
                 }
                 catch (Throwable throwable)
@@ -1432,9 +1778,12 @@
 
                         if (movingobjectposition1 != null)
                         {
+                            vec32.myVec3LocalPool.release(vec32); // CraftBukkit
                             return movingobjectposition1;
                         }
                     }
+
+                    vec32.myVec3LocalPool.release(vec32); // CraftBukkit
                 }
 
                 return null;
@@ -1543,41 +1892,128 @@
         return true;
     }
 
+    // CraftBukkit start - Used for entities other than creatures
+
     /**
      * Called to place all entities as part of a world
      */
     public boolean spawnEntityInWorld(Entity par1Entity)
     {
-        int i = MathHelper.floor_double(par1Entity.posX / 16.0D);
-        int j = MathHelper.floor_double(par1Entity.posZ / 16.0D);
-        boolean flag = par1Entity.forceSpawn;
+        return this.addEntity(par1Entity, SpawnReason.DEFAULT); // Set reason as DEFAULT
+    }
 
-        if (par1Entity instanceof EntityPlayer)
+    public boolean addEntity(Entity entity, SpawnReason spawnReason)   // Changed signature, added SpawnReason
+    {
+        // Cauldron start - do not drop any items while restoring blockstates. Fixes dupes in mods such as Flans
+        if (entity == null || (entity instanceof EntityItem && this.restoringBlockStates))
         {
+            return false;
+        }
+        // Cauldron end
+
+        int i = MathHelper.floor_double(entity.posX / 16.0D);
+        int j = MathHelper.floor_double(entity.posZ / 16.0D);
+        boolean flag = entity.forceSpawn;
+
+        if (entity instanceof EntityPlayer)
+        {
             flag = true;
         }
+        
+        // CraftBukkit start
+        org.bukkit.event.Cancellable event = null;
+        // Cauldron start - workaround for handling CraftBukkit's SpawnReason with customspawners and block spawners
+        if (entity.spawnReason != null && entity.spawnReason.equals("natural"))
+        {
+            spawnReason = SpawnReason.NATURAL;
+        }
+        else if (entity.spawnReason != null && entity.spawnReason.equals("spawner"))
+        {
+            spawnReason = SpawnReason.SPAWNER;
+        }
+        // Cauldron end
 
+        if (entity instanceof EntityLivingBase && !(entity instanceof EntityPlayerMP))
+        {
+            // Cauldron start - add custom entity support
+            boolean isAnimal = entity instanceof EntityAnimal || entity instanceof EntityWaterMob || entity instanceof EntityGolem || entity.isCreatureType(EnumCreatureType.creature, false);
+            boolean isMonster = entity instanceof EntityMob || entity instanceof EntityGhast || entity instanceof EntitySlime || entity.isCreatureType(EnumCreatureType.monster, false);
+            // Cauldron end
+
+            if (spawnReason != SpawnReason.CUSTOM)
+            {
+                if (isAnimal && !spawnPeacefulMobs || isMonster && !spawnHostileMobs)
+                {
+                    entity.isDead = true;
+                    return false;
+                }
+            }
+
+            event = CraftEventFactory.callCreatureSpawnEvent((EntityLivingBase) entity, spawnReason);
+        }
+        else if (entity instanceof EntityItem)
+        {
+            event = CraftEventFactory.callItemSpawnEvent((EntityItem) entity);
+        }
+        else if (entity.getBukkitEntity() instanceof org.bukkit.entity.Projectile)
+        {
+            // Not all projectiles extend EntityProjectile, so check for Bukkit interface instead
+            event = CraftEventFactory.callProjectileLaunchEvent(entity);
+        }
+        // Spigot start
+        else if (entity instanceof EntityXPOrb)
+        {
+            EntityXPOrb xp = (EntityXPOrb) entity;
+            double radius = this.spigotConfig.expMerge;
+            if (radius > 0)
+            {
+                List<Entity> entities = this.getEntitiesWithinAABBExcludingEntity(entity, entity.boundingBox.expand(radius, radius, radius));
+                for (Entity e : entities)
+                {
+                    if (e instanceof EntityXPOrb)
+                    {
+                        EntityXPOrb loopItem = (EntityXPOrb) e;
+                        if (!loopItem.isDead)
+                        {
+                            xp.xpValue += loopItem.xpValue;
+                            loopItem.setDead();
+                        }
+                    }
+                }
+            }
+        } // Spigot end
+
+        if (event != null && (event.isCancelled() || entity.isDead))
+        {
+            entity.isDead = true;
+            return false;
+        }
+
+        // CraftBukkit end
+
         if (!flag && !this.chunkExists(i, j))
         {
+            entity.isDead = true; // CraftBukkit
             return false;
         }
         else
         {
-            if (par1Entity instanceof EntityPlayer)
+            if (entity instanceof EntityPlayer)
             {
-                EntityPlayer entityplayer = (EntityPlayer)par1Entity;
+                EntityPlayer entityplayer = (EntityPlayer) entity;
                 this.playerEntities.add(entityplayer);
                 this.updateAllPlayersSleepingFlag();
             }
 
-            if (MinecraftForge.EVENT_BUS.post(new EntityJoinWorldEvent(par1Entity, this)) && !flag)
+            if (MinecraftForge.EVENT_BUS.post(new EntityJoinWorldEvent(entity, this)) && !flag)
             {
                 return false;
             }
 
-            this.getChunkFromChunkCoords(i, j).addEntity(par1Entity);
-            this.loadedEntityList.add(par1Entity);
-            this.onEntityAdded(par1Entity);
+            this.getChunkFromChunkCoords(i, j).addEntity(entity);
+            this.loadedEntityList.add(entity);
+            this.onEntityAdded(entity);
+            net.minecraftforge.cauldron.CauldronHooks.logEntitySpawn(this, entity, spawnReason);
             return true;
         }
     }
@@ -1588,6 +2024,7 @@
         {
             ((IWorldAccess)this.worldAccesses.get(i)).onEntityCreate(par1Entity);
         }
+        par1Entity.valid = true; // CraftBukkit
     }
 
     public void onEntityRemoved(Entity par1Entity)
@@ -1596,6 +2033,7 @@
         {
             ((IWorldAccess)this.worldAccesses.get(i)).onEntityDestroy(par1Entity);
         }
+        par1Entity.valid = false; // CraftBukkit
     }
 
     /**
@@ -1627,6 +2065,10 @@
      */
     public void removePlayerEntityDangerously(Entity par1Entity)
     {
+        if (Thread.currentThread() != MinecraftServer.getServer().primaryThread)
+        {
+            throw new IllegalStateException("Asynchronous entity remove!");    // Spigot
+        }
         par1Entity.setDead();
 
         if (par1Entity instanceof EntityPlayer)
@@ -1643,7 +2085,20 @@
             this.getChunkFromChunkCoords(i, j).removeEntity(par1Entity);
         }
 
-        this.loadedEntityList.remove(par1Entity);
+        // CraftBukkit start - Decrement loop variable field if we've already ticked this entity
+        int index = this.loadedEntityList.indexOf(par1Entity);
+
+        if (index != -1)
+        {
+            if (index <= this.tickPosition)
+            {
+                this.tickPosition--;
+            }
+
+            this.loadedEntityList.remove(index);
+        }
+
+        // CraftBukkit end
         this.onEntityRemoved(par1Entity);
     }
 
@@ -1661,6 +2116,7 @@
      */
     public List getCollidingBoundingBoxes(Entity par1Entity, AxisAlignedBB par2AxisAlignedBB)
     {
+        long time = System.currentTimeMillis();
         this.collidingBoundingBoxes.clear();
         int i = MathHelper.floor_double(par2AxisAlignedBB.minX);
         int j = MathHelper.floor_double(par2AxisAlignedBB.maxX + 1.0D);
@@ -1669,14 +2125,63 @@
         int i1 = MathHelper.floor_double(par2AxisAlignedBB.minZ);
         int j1 = MathHelper.floor_double(par2AxisAlignedBB.maxZ + 1.0D);
 
-        for (int k1 = i; k1 < j; ++k1)
+        if (CauldronHooks.checkBoundingBoxSize(par1Entity, par2AxisAlignedBB)) return new ArrayList(); // Removing misbehaved entities
+
+        // Spigot start
+        int ystart = ((k - 1) < 0) ? 0 : (k - 1);
+
+        for (int chunkx = (i >> 4); chunkx <= ((j - 1) >> 4); chunkx++)
         {
+            int cx = chunkx << 4;
+
+            for (int chunkz = (i1 >> 4); chunkz <= ((j1 - 1) >> 4); chunkz++)
+            {
+                if (!this.chunkExists(chunkx, chunkz))
+                {
+                    continue;
+                }
+
+                int cz = chunkz << 4;
+                Chunk chunk = this.getChunkFromChunkCoords(chunkx, chunkz);
+                // Compute ranges within chunk
+                int xstart = (i < cx) ? cx : i;
+                int xend = (j < (cx + 16)) ? j : (cx + 16);
+                int zstart = (i1 < cz) ? cz : i1;
+                int zend = (j1 < (cz + 16)) ? j1 : (cz + 16);
+
+                // Loop through blocks within chunk
+                for (int x = xstart; x < xend; x++)
+                {
+                    for (int z = zstart; z < zend; z++)
+                    {
+                        for (int y = ystart; y < l; y++)
+                        {
+                            int blkid = chunk.getBlockID(x - cx, y, z - cz);
+
+                            if (blkid > 0)
+                            {
+                                Block block = Block.blocksList[blkid];
+
+                                if (block != null)
+                                {
+                                    block.addCollisionBoxesToList(this, x, y, z, par2AxisAlignedBB, this.collidingBoundingBoxes, par1Entity);
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        /*for (int k1 = i; k1 < j; ++k1)
+        {
             for (int l1 = i1; l1 < j1; ++l1)
             {
                 if (this.blockExists(k1, 64, l1))
                 {
                     for (int i2 = k - 1; i2 < l; ++i2)
                     {
+                        lastBoundingBoxCoords = new ChunkCoordinates(k1, i2, l1);
                         Block block = Block.blocksList[this.getBlockId(k1, i2, l1)];
 
                         if (block != null)
@@ -1686,11 +2191,13 @@
                     }
                 }
             }
-        }
+        }*/// Spigot end
 
         double d0 = 0.25D;
         List list = this.getEntitiesWithinAABBExcludingEntity(par1Entity, par2AxisAlignedBB.expand(d0, d0, d0));
 
+        net.minecraftforge.cauldron.CauldronHooks.logEntitySize(this, par1Entity, list); // Cauldron add logging for entity collisions
+
         for (int j2 = 0; j2 < list.size(); ++j2)
         {
             AxisAlignedBB axisalignedbb1 = ((Entity)list.get(j2)).getBoundingBox();
@@ -2067,11 +2574,22 @@
         Entity entity;
         CrashReport crashreport;
         CrashReportCategory crashreportcategory;
+        // Cauldron start
+        entitiesTicked = 0;
+        tilesTicked = 0;
+        // Cauldron end
 
         for (i = 0; i < this.weatherEffects.size(); ++i)
         {
             entity = (Entity)this.weatherEffects.get(i);
+            // CraftBukkit start - Fixed an NPE
+            if (entity == null)
+            {
+                continue;
+            }
 
+            // CraftBukkit end
+
             try
             {
                 ++entity.ticksExisted;
@@ -2132,10 +2650,13 @@
 
         this.unloadedEntityList.clear();
         this.theProfiler.endStartSection("regular");
+        org.spigotmc.ActivationRange.activateEntities(this); // Spigot
+        timings.entityTick.startTiming(); // Spigot
 
-        for (i = 0; i < this.loadedEntityList.size(); ++i)
+        // CraftBukkit start - Use field for loop variable
+        for (this.tickPosition = 0; this.tickPosition < this.loadedEntityList.size(); ++this.tickPosition)
         {
-            entity = (Entity)this.loadedEntityList.get(i);
+            entity = (Entity) this.loadedEntityList.get(this.tickPosition);
 
             if (entity.ridingEntity != null)
             {
@@ -2154,7 +2675,13 @@
             {
                 try
                 {
+                    SpigotTimings.tickEntityTimer.startTiming(); // Spigot
+                    // Cauldron start - mobius hooks
+                    ProfilerSection.ENTITY_UPDATETIME.start(entity);
                     this.updateEntity(entity);
+                    ProfilerSection.ENTITY_UPDATETIME.stop(entity);
+                    // Cauldron end
+                    SpigotTimings.tickEntityTimer.stopTiming(); // Spigot
                 }
                 catch (Throwable throwable1)
                 {
@@ -2187,29 +2714,48 @@
                     this.getChunkFromChunkCoords(j, k).removeEntity(entity);
                 }
 
-                this.loadedEntityList.remove(i--);
+                this.loadedEntityList.remove(this.tickPosition--); // CraftBukkit - Use field for loop variable
                 this.onEntityRemoved(entity);
             }
 
             this.theProfiler.endSection();
         }
 
+        timings.entityTick.stopTiming(); // Spigot
         this.theProfiler.endStartSection("tileEntities");
+        timings.tileEntityTick.startTiming(); // Spigot
         this.scanningTileEntities = true;
+
         Iterator iterator = this.loadedTileEntityList.iterator();
 
         while (iterator.hasNext())
         {
             TileEntity tileentity = (TileEntity)iterator.next();
 
-            if (!tileentity.isInvalid() && tileentity.hasWorldObj() && this.blockExists(tileentity.xCoord, tileentity.yCoord, tileentity.zCoord))
+            // Spigot start
+            if (tileentity == null)
             {
+                getServer().getLogger().severe("Cauldron has detected a null entity and has removed it, preventing a crash");
+                iterator.remove();
+                continue;
+            }
+
+            // Spigot end
+
+            if (!tileentity.isInvalid() && tileentity.hasWorldObj() && CauldronHooks.canTileEntityTick(tileentity, this) && this.blockExists(tileentity.xCoord, tileentity.yCoord, tileentity.zCoord))
+            {
                 try
                 {
+                    tileentity.tickTimer.startTiming(); // Spigot
+                    tilesTicked++;
+                    ProfilerSection.TILEENT_UPDATETIME.start(tileentity); // mobius hook
                     tileentity.updateEntity();
+                    ProfilerSection.TILEENT_UPDATETIME.stop(tileentity); // mobius hook
+                    tileentity.tickTimer.stopTiming(); // Spigot
                 }
                 catch (Throwable throwable2)
                 {
+                    tileentity.tickTimer.stopTiming(); // Spigot
                     crashreport = CrashReport.makeCrashReport(throwable2, "Ticking tile entity");
                     crashreportcategory = crashreport.makeCategory("Tile entity being ticked");
                     tileentity.func_85027_a(crashreportcategory);
@@ -2242,6 +2788,9 @@
             }
         }
 
+        timings.tileEntityTick.stopTiming(); // Spigot
+        timings.tileEntityPending.startTiming(); // Spigot
+        this.scanningTileEntities = false;
 
         if (!this.entityRemoval.isEmpty())
         {
@@ -2253,8 +2802,6 @@
             this.entityRemoval.clear();
         }
 
-        this.scanningTileEntities = false;
-
         this.theProfiler.endStartSection("pendingTileEntities");
 
         if (!this.addedTileEntityList.isEmpty())
@@ -2287,16 +2834,17 @@
             this.addedTileEntityList.clear();
         }
 
+        timings.tileEntityPending.stopTiming(); // Spigot
         this.theProfiler.endSection();
         this.theProfiler.endSection();
     }
 
     public void addTileEntity(Collection par1Collection)
     {
-        List dest = scanningTileEntities ? addedTileEntityList : loadedTileEntityList;
+        Collection dest = scanningTileEntities ? addedTileEntityList : loadedTileEntityList; // Cauldron - List -> Collection for CB loadedTileEntityList type change
         for(Object entity : par1Collection)
         {
-            if(((TileEntity)entity).canUpdate())
+            if(CauldronHooks.canUpdate((TileEntity)entity))
             {
                 dest.add(entity);
             }
@@ -2318,19 +2866,31 @@
     public void updateEntityWithOptionalForce(Entity par1Entity, boolean par2)
     {
         int i = MathHelper.floor_double(par1Entity.posX);
-        int j = MathHelper.floor_double(par1Entity.posZ);
+        int j = MathHelper.floor_double(par1Entity.posZ); 
 
         boolean isForced = getPersistentChunks().containsKey(new ChunkCoordIntPair(i >> 4, j >> 4));
         byte b0 = isForced ? (byte)0 : 32;
         boolean canUpdate = !par2 || this.checkChunksExist(i - b0, 0, j - b0, i + b0, 0, j + b0);
+        boolean forceUpdate = false; // Cauldron
         if (!canUpdate)
         {
             EntityEvent.CanUpdate event = new EntityEvent.CanUpdate(par1Entity);
             MinecraftForge.EVENT_BUS.post(event);
             canUpdate = event.canUpdate;
+            forceUpdate = canUpdate; // Cauldron
         }
+        // Spigot start
+        if (!isForced && !forceUpdate && !org.spigotmc.ActivationRange.checkIfActive(par1Entity)) // Cauldron - ignore if forge event forced update or entity is in forced chunk
+        {
+            par1Entity.ticksExisted++;
+            par1Entity.inactiveTick();
+            return;
+        }
+        // Spigot end
         if (canUpdate)
         {
+            par1Entity.tickTimer.startTiming();
+            entitiesTicked++;
             par1Entity.lastTickPosX = par1Entity.posX;
             par1Entity.lastTickPosY = par1Entity.posY;
             par1Entity.lastTickPosZ = par1Entity.posZ;
@@ -2414,6 +2974,7 @@
                     par1Entity.riddenByEntity = null;
                 }
             }
+            par1Entity.tickTimer.stopTiming(); // Spigot
         }
     }
 
@@ -2631,6 +3192,7 @@
                 par3Entity.motionZ += vec3.zCoord * d1;
             }
 
+            vec3.myVec3LocalPool.release(vec3); // CraftBukkit - pop it - we're done
             return flag;
         }
     }
@@ -2739,6 +3301,7 @@
         double d2 = 1.0D / ((par2AxisAlignedBB.maxZ - par2AxisAlignedBB.minZ) * 2.0D + 1.0D);
         int i = 0;
         int j = 0;
+        Vec3 vec32 = par1Vec3.myVec3LocalPool.getVecFromPool(0, 0, 0); // CraftBukkit
 
         for (float f = 0.0F; f <= 1.0F; f = (float)((double)f + d0))
         {
@@ -2750,7 +3313,7 @@
                     double d4 = par2AxisAlignedBB.minY + (par2AxisAlignedBB.maxY - par2AxisAlignedBB.minY) * (double)f1;
                     double d5 = par2AxisAlignedBB.minZ + (par2AxisAlignedBB.maxZ - par2AxisAlignedBB.minZ) * (double)f2;
 
-                    if (this.clip(this.getWorldVec3Pool().getVecFromPool(d3, d4, d5), par1Vec3) == null)
+                    if (this.clip(vec32.func_72439_b_CodeFix_Public(d3, d4, d5), par1Vec3) == null)   // CraftBukkit
                     {
                         ++i;
                     }
@@ -2760,6 +3323,7 @@
             }
         }
 
+        vec32.myVec3LocalPool.release(vec32); // CraftBukkit
         return (float)i / (float)j;
     }
 
@@ -2898,7 +3462,7 @@
             return;
         }
 
-        if (par4TileEntity.canUpdate())
+        if (CauldronHooks.canUpdate(par4TileEntity))
         {
             if (scanningTileEntities)
             {
@@ -3112,7 +3676,14 @@
 
                 if (i <= 0)
                 {
-                    this.worldInfo.setThundering(!this.worldInfo.isThundering());
+                    // CraftBukkit start
+                    ThunderChangeEvent thunder = new ThunderChangeEvent(this.getWorld(), !this.worldInfo.isThundering());
+                    this.getServer().getPluginManager().callEvent(thunder);
+                    if (!thunder.isCancelled())
+                    {
+                        this.worldInfo.setThundering(!this.worldInfo.isThundering());
+                    }
+                    // CraftBukkit end
                 }
             }
 
@@ -3136,7 +3707,14 @@
 
                 if (j <= 0)
                 {
-                    this.worldInfo.setRaining(!this.worldInfo.isRaining());
+                    // CraftBukkit start
+                    WeatherChangeEvent weather = new WeatherChangeEvent(this.getWorld(), !this.worldInfo.isRaining());
+                    this.getServer().getPluginManager().callEvent(weather);
+                    if (!weather.isCancelled())
+                    {
+                        this.worldInfo.setRaining(!this.worldInfo.isRaining());
+                    }
+                    // CraftBukkit end
                 }
             }
 
@@ -3189,33 +3767,84 @@
         provider.toggleRain();
     }
 
+    // Spigot start
+    protected float modifiedOdds = 100F;
+    public float growthOdds = 100F;
+
     protected void setActivePlayerChunksAndCheckLight()
     {
-        this.activeChunkSet.clear();
-        this.activeChunkSet.addAll(getPersistentChunks().keySet());
+        // Cauldron start - add persistent chunks to be ticked for growth
+        activeChunkSet.clear();
+        activeChunkSet_CB.clear();
+        for(ChunkCoordIntPair chunk : getPersistentChunks().keySet()) {
+            this.activeChunkSet.add(chunk);
+            long key = chunkToKey(chunk.chunkXPos, chunk.chunkZPos);
+            activeChunkSet_CB.put(key, (short) 0);
+            if (!this.chunkExists(chunk.chunkXPos, chunk.chunkZPos)) {
+                ((WorldServer)this).theChunkProviderServer.loadChunk(chunk.chunkXPos, chunk.chunkZPos);
+            }
+        }
+        // Cauldron end
 
+        // this.chunkTickList.clear(); // CraftBukkit - removed
         this.theProfiler.startSection("buildList");
         int i;
         EntityPlayer entityplayer;
         int j;
         int k;
+        final int optimalChunks = spigotConfig.chunksPerTick;
 
+        if (optimalChunks <= 0) // Cauldron tick chunks even if no players are logged in
+        {
+            return;
+        }
+
+        // Keep chunks with growth inside of the optimal chunk range
+        int chunksPerPlayer = Math.min(200, Math.max(1, (int)(((optimalChunks - playerEntities.size()) / (double) playerEntities.size()) + 0.5)));
+        int randRange = 3 + chunksPerPlayer / 30;
+        // Limit to normal tick radius - including view distance
+        randRange = ( randRange > chunkTickRadius ) ? chunkTickRadius : randRange;
+        // Cauldron start - validate view radius
+        if (randRange < 1)
+        {
+            throw new IllegalArgumentException("Too small view radius! edit server.properties and change view-distance to a value > 0.");
+        }
+        // Cauldron end
+        // odds of growth happening vs growth happening in vanilla
+        this.growthOdds = this.modifiedOdds = Math.max( 35, Math.min( 100, ( ( chunksPerPlayer + 1 ) * 100F ) / 15F ) );
+        // Spigot end
         for (i = 0; i < this.playerEntities.size(); ++i)
         {
             entityplayer = (EntityPlayer)this.playerEntities.get(i);
-            j = MathHelper.floor_double(entityplayer.posX / 16.0D);
-            k = MathHelper.floor_double(entityplayer.posZ / 16.0D);
-            byte b0 = 7;
+            int chunkX = MathHelper.floor_double(entityplayer.posX / 16.0D);
+            int chunkZ = MathHelper.floor_double(entityplayer.posZ / 16.0D);
+            // Spigot start - Always update the chunk the player is on
+            long key = chunkToKey(chunkX, chunkZ);
+            int existingPlayers = Math.max(0, activeChunkSet_CB.get(key)); //filter out -1's
+            activeChunkSet_CB.put(key, (short)(existingPlayers + 1));
+            activeChunkSet.add(new ChunkCoordIntPair(chunkX, chunkZ)); // Cauldron - vanilla compatibility
 
-            for (int l = -b0; l <= b0; ++l)
+            // Check and see if we update the chunks surrounding the player this tick
+            for (int chunk = 0; chunk < chunksPerPlayer; chunk++)
             {
-                for (int i1 = -b0; i1 <= b0; ++i1)
+                int dx = (rand.nextBoolean() ? 1 : -1) * rand.nextInt(randRange);
+                int dz = (rand.nextBoolean() ? 1 : -1) * rand.nextInt(randRange);
+                long hash = chunkToKey(dx + chunkX, dz + chunkZ);
+
+                if (!activeChunkSet_CB.contains(hash) && this.chunkExists(dx + chunkX, dz + chunkZ))
                 {
-                    this.activeChunkSet.add(new ChunkCoordIntPair(l + j, i1 + k));
+                    activeChunkSet_CB.put(hash, (short) - 1); //no players
+                    activeChunkSet.add(new ChunkCoordIntPair(dx + chunkX, dz + chunkZ)); // Cauldron - vanilla compatibility
                 }
             }
         }
+        /*for (ChunkCoordIntPair coord : getPersistentChunks().keySet())
+        {
+            long key = chunkToKey(coord.chunkXPos, coord.chunkZPos);
+            activeChunkSet.put(key, (short) - 1); //no players
+        }*/
 
+        // Spigot End
         this.theProfiler.endSection();
 
         if (this.ambientTickCountdown > 0)
@@ -3225,7 +3854,7 @@
 
         this.theProfiler.startSection("playerCheckLight");
 
-        if (!this.playerEntities.isEmpty())
+        if (spigotConfig.randomLightUpdates && !this.playerEntities.isEmpty()) // Spigot
         {
             i = this.rand.nextInt(this.playerEntities.size());
             entityplayer = (EntityPlayer)this.playerEntities.get(i);
@@ -3248,7 +3877,7 @@
             int k = this.updateLCG >> 2;
             int l = k & 15;
             int i1 = k >> 8 & 15;
-            int j1 = k >> 16 & 127;
+            int j1 = k >> 16 & 255; // CraftBukkit - 127 -> 255
             int k1 = par3Chunk.getBlockID(l, j1, i1);
             l += par1;
             i1 += par2;
@@ -3729,10 +4358,23 @@
         {
             Entity entity = (Entity)this.loadedEntityList.get(j);
 
-            if ((!(entity instanceof EntityLiving) || !((EntityLiving)entity).isNoDespawnRequired()) && par1Class.isAssignableFrom(entity.getClass()))
+            // CraftBukkit start - Split out persistent check, don't apply it to special persistent mobs
+            if (entity instanceof EntityLiving)
             {
+                EntityLiving entityliving = (EntityLiving) entity;
+
+                if (entityliving.func_70692_ba_CodeFix_Public() && entityliving.isNoDespawnRequired())   // Should be isPersistent
+                {
+                    continue;
+                }
+            }
+
+            if (par1Class.isAssignableFrom(entity.getClass()))
+            {
                 ++i;
             }
+
+            // CraftBukkit end
         }
 
         return i;
@@ -3743,9 +4385,19 @@
      */
     public void addLoadedEntities(List par1List)
     {
+        // CraftBukkit start
+        Entity entity = null;
+
         for (int i = 0; i < par1List.size(); ++i)
         {
-            Entity entity = (Entity)par1List.get(i);
+            entity = (Entity) par1List.get(i);
+
+            if (entity == null)
+            {
+                continue;
+            }
+
+            // CraftBukkit end
             if (!MinecraftForge.EVENT_BUS.post(new EntityJoinWorldEvent(entity, this)))
             {
                 loadedEntityList.add(entity);
@@ -3770,6 +4422,7 @@
         int j1 = this.getBlockId(par2, par3, par4);
         Block block = Block.blocksList[j1];
         Block block1 = Block.blocksList[par1];
+        if (block1 == null) return false; // Cauldron
         AxisAlignedBB axisalignedbb = block1.getCollisionBoundingBoxFromPool(this, par2, par3, par4);
 
         if (par5)
@@ -3777,9 +4430,11 @@
             axisalignedbb = null;
         }
 
+        boolean defaultReturn; // CraftBukkit - store the default action
+
         if (axisalignedbb != null && !this.checkNoEntityCollision(axisalignedbb, par7Entity))
         {
-            return false;
+            defaultReturn = false; // CraftBukkit
         }
         else
         {
@@ -3788,13 +4443,20 @@
                 block = null;
             }
 
+            // CraftBukkit
+
             if (block != null && block.isBlockReplaceable(this, par2, par3, par4))
             {
                 block = null;
             }
 
-            return block != null && block.blockMaterial == Material.circuits && block1 == Block.anvil ? true : par1 > 0 && block == null && block1.canPlaceBlockOnSide(this, par2, par3, par4, par6, par8ItemStack);
+            defaultReturn = block != null && block.blockMaterial == Material.circuits && block1 == Block.anvil ? true : par1 > 0 && block == null && block1.canPlaceBlockOnSide(this, par2, par3, par4, par6, par8ItemStack);
         }
+
+        // CraftBukkit start
+        BlockCanBuildEvent event = new BlockCanBuildEvent(this.getWorld().getBlockAt(par2, par3, par4), par1, defaultReturn);
+        this.getServer().getPluginManager().callEvent(event);
+        return event.isBuildable();
     }
 
     public PathEntity getPathEntityToEntity(Entity par1Entity, Entity par2Entity, float par3, boolean par4, boolean par5, boolean par6, boolean par7)
@@ -3982,6 +4644,12 @@
         for (int i = 0; i < this.playerEntities.size(); ++i)
         {
             EntityPlayer entityplayer1 = (EntityPlayer)this.playerEntities.get(i);
+            // CraftBukkit start - Fixed an NPE
+            if (entityplayer1 == null || entityplayer1.isDead)
+            {
+                continue;
+            }
+            // CraftBukkit end
             double d5 = entityplayer1.getDistanceSq(par1, par3, par5);
 
             if ((par7 < 0.0D || d5 < par7 * par7) && (d4 == -1.0D || d5 < d4))
@@ -4013,6 +4681,12 @@
         for (int i = 0; i < this.playerEntities.size(); ++i)
         {
             EntityPlayer entityplayer1 = (EntityPlayer)this.playerEntities.get(i);
+            // CraftBukkit start - Fixed an NPE
+            if (entityplayer1 == null || entityplayer1.isDead)
+            {
+                continue;
+            }
+            // CraftBukkit end
 
             if (!entityplayer1.capabilities.disableDamage && entityplayer1.isEntityAlive())
             {
@@ -4219,6 +4893,18 @@
      */
     public void updateAllPlayersSleepingFlag() {}
 
+    // CraftBukkit start
+    // Calls the method that checks to see if players are sleeping
+    // Called by CraftPlayer.setPermanentSleeping()
+    public void checkSleepStatus()
+    {
+        if (!this.isRemote)
+        {
+            this.updateAllPlayersSleepingFlag();
+        }
+    }
+    // CraftBukkit end
+
     public float getWeightedThunderStrength(float par1)
     {
         return (this.prevThunderingStrength + (this.thunderingStrength - this.prevThunderingStrength) * par1) * this.getRainStrength(par1);
@@ -4544,14 +5230,18 @@
         return MathHelper.clamp_float(f, 0.0F, flag ? 1.5F : 1.0F);
     }
 
+    public boolean func_72916_c_CodeFix_Public(int a, int b){
+        return chunkExists(a, b);
+    }
+
     /**
      * Adds a single TileEntity to the world.
      * @param entity The TileEntity to be added.
      */
     public void addTileEntity(TileEntity entity)
     {
-        List dest = scanningTileEntities ? addedTileEntityList : loadedTileEntityList;
-        if(entity.canUpdate())
+        Collection dest = scanningTileEntities ? addedTileEntityList : loadedTileEntityList; // Cauldron - List -> Collection for CB loadedTileEntityList type change
+        if(CauldronHooks.canUpdate(entity))
         {
             dest.add(entity);
         }
@@ -4654,4 +5344,43 @@
         }
         return count;
     }
+
+    // Cauldron start
+    public boolean isActiveChunk(int x, int z)
+    {
+        return getPersistentChunks().containsKey(new ChunkCoordIntPair(x, z)) || activeChunkSet_CB.containsKey(chunkToKey(x, z));
+    }
+
+    public boolean isActiveChunk(long key)
+    {
+        return isActiveChunk(keyToX(key), keyToZ(key));
+    }
+
+    public boolean isActiveBlockCoord(int x, int z)
+    {
+        return isActiveChunk(x >> 4, z >> 4);
+    }
+    
+    public boolean inActiveChunk(Entity entity)
+    {
+        return isActiveBlockCoord(MathHelper.floor_double(entity.posX), MathHelper.floor_double(entity.posZ));
+    }
+
+    // this method is used by ForgeMultipart and Immibis's Microblocks
+    public boolean canPlaceMultipart(Block block, int x, int y, int z)
+    {
+        BlockPlaceEvent placeEvent = null;
+        if (ItemStack.currentPlayer != null)
+        {
+            placeEvent = org.bukkit.craftbukkit.event.CraftEventFactory.callBlockPlaceEvent(this, ItemStack.currentPlayer, org.bukkit.craftbukkit.block.CraftBlockState.getBlockState(this, x, y, z, 3), x, y, z);
+        }
+
+        if (placeEvent != null && (placeEvent.isCancelled() || !placeEvent.canBuild()))
+        {
+            return false;
+        }
+
+        return true;
+    }
+    // Cauldron end
 }
